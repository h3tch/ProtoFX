// AUTHOR: Michael Hecher

csharp cs_util {
	file "<csharp>/StaticCamera.cs" ...
	     "<csharp>/SimpleCamera.cs" ...
	     "<csharp>/UniformBlock.cs" ...
	     "<csharp>/CsObject.cs"
}

/////////////
// BUFFERS //
/////////////

memory mem_clear_min {
	xml "scene.xml" data/number/uint_max
}

memory mem_clear_max {
	xml "scene.xml" data/number/uint_zero
}

buffer buff_pos {
	// buffer will only be used for reading
	// and will not be updated during runtime
	usage staticDraw
	// load <pos></pos> data from XML file
	// these are vertex positions for each vertex
	xml "../geom/cube.xml" data/position
	xml "../geom/plane.xml" data/position
}

buffer buff_color {
	usage staticDraw
	xml "../geom/cube.xml" data/color
	xml "../geom/plane.xml" data/color
}

buffer buf_idx {
	usage staticDraw
	xml "../geom/cube.xml" data/index
	xml "../geom/plane.xml" data/index
}

buffer buf_resolution_min {
	target atomic
	usage staticDraw
	size 4
}

buffer buf_resolution_max {
	target atomic
	usage staticDraw
	size 4
}

image img_shadowmap {
	// image size in pixels
	size 128 128
	// pixel format is a 32
	// bit floating point depth
	format depth32f
}

/////////////////////
// BUFFER BINDINGS //
/////////////////////

vertinput in_vert {
	// first attribute: floating point
	// vertex positions (x,y,z,1)
	attr buff_pos float 4
	// second attribute: floating point
	// vertex colors (x,y,z,1)
	attr buff_color float 4
}

sampler samp_linear {
	minfilter linear
	magfilter linear
}

fragoutput out_shadowmap {
	// depth attachment
	depth img_shadowmap
}

texture tex_shadowmap {
	img img_shadowmap
}

//////////////
// CONTROLS //
//////////////

instance cs_light {
	class cs_util csharp.StaticCamera
	name StaticCamera
	pos 3 4 3
	rot -45 45 0
}

instance cs_camera {
	class cs_util csharp.SimpleCamera
	name SimpleCamera
	pos -5 4 10
	rot -20 -15 0
}

/////////////
// SHADERS //
/////////////

shader vs_shadowmap vert {
	#version 440
	
	layout(binding = 0) uniform StaticCamera {
		mat4 viewProj;
	} light;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 in_pos;

	out gl_PerVertex {
		vec4 gl_Position;
	};
	
	void main ()
	{
		// transform vertex to light projection space
		gl_Position = light.viewProj * in_pos;
	}
}

shader vs_simple vert {
	#version 450
	
	layout(binding = 0) uniform StaticCamera {
		mat4 viewProj;
	} light;
	
	layout(binding = 1) uniform SimpleCamera {
		mat4 viewProj;
	} camera;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 in_pos;
	layout(location = 1) in vec4 in_col;

	// vertex shader output
	layout(location = 0) out vec3 out_wpos;
	layout(location = 1) out vec4 out_lpos;
	layout(location = 2) out vec4 out_col;
	out gl_PerVertex {
		vec4 gl_Position;
	};
	
	void main ()
	{
		// transform vertex to camera projection space
		gl_Position = camera.viewProj * in_pos;
		// transform vertex to light projection space
		out_lpos = light.viewProj * in_pos;
		// pass vertex color
		out_col = in_col;
		out_wpos = in_pos.xyz;
	}
}

shader fs_simple frag {
	#version 450
	#extension GL_ARB_shader_atomic_counter_ops : require
	
	layout(binding = 0) uniform StaticCamera {
		mat4 viewProj;
	} light;
	
	layout(binding = 0) uniform sampler2D shadowmap;
	layout(binding = 0) uniform atomic_uint resolution_min[2];
	layout(binding = 2) uniform atomic_uint resolution_max[2];
	
	layout(location = 0) in vec3 in_wpos;
	layout(location = 1) in vec4 in_lpos;
	layout(location = 2) in vec4 in_col;
	out vec4 color;
	
	//layout(pixel_center_integer) in vec4 gl_FragCoord;
	
	vec2 depthGradient(vec3 lpos)
	{
		vec2 dz_duv;
		vec3 duvdist_dx = dFdx(lpos);
		vec3 duvdist_dy = dFdy(lpos);

		dz_duv.x = duvdist_dy.y * duvdist_dx.z;
		dz_duv.x -= duvdist_dx.y * duvdist_dy.z;

		dz_duv.y = duvdist_dx.x * duvdist_dy.z;
		dz_duv.y -= duvdist_dy.x * duvdist_dx.z;

		dz_duv /= (duvdist_dx.x * duvdist_dy.y) - (duvdist_dx.y * duvdist_dy.x);

		return dz_duv;
	}
	
	void main ()
	{
		color = in_col;
		
		// if pixel outside light frustum clip space, do nothing
		if (any(greaterThan(abs(in_lpos), in_lpos.wwww)))
			return;
			
		// SHADOW MAPPING
		
		// transform to normalized device coordinates [-1;+1]
		// and then to shadow map texture coordinates [0;1]
		vec3 lpos = (in_lpos.xyz / in_lpos.w) * 0.5 + 0.5;
		vec2 grad = depthGradient(lpos);
		
		int shadow = 0;
		for (int u = -1; u <= 1; u++)
		{
			for (int v = -1; v <= 1; v++)
			{
				// if pixel distance from the light source is greader than
				// the distance in the shadow map, the pixel is in shadow
				ivec2 offset = ivec2(u, v);
				vec2 uvoffset = vec2(offset) / textureSize(shadowmap, 0).xy;
				float z = lpos.z + dot(grad, uvoffset);
				shadow += int(z - 0.0003 > textureOffset(shadowmap, lpos.xy, offset).x);
			}
		}
		
		vec3 dx = dFdx(in_wpos);
		vec3 dy = dFdy(in_wpos);
		
		if (shadow == 0 || shadow == 9) {
			return;
		} else {
			vec3 p[4];
			p[0] = in_wpos;
			p[1] = p[0] + dx;
			p[2] = p[0] + dy;
			p[3] = p[1] + dy;
			
			for (int i = 0; i < 4; i++) 
			{
				vec4 v = light.viewProj * vec4(p[i], 1.0);
				p[i] = (v.xyz / v.w) * 0.5 + 0.5;
			}
			
			vec2 wh = max(max(p[0], p[1]), max(p[2], p[3])).xy;
			wh -= min(min(p[0], p[1]), min(p[2], p[3])).xy;
			
			// pass color
			color = vec4(wh * 100, 0, 1);
			wh *= textureSize(shadowmap, 0).xy;
			atomicCounterMinARB(resolution_min[0], floatBitsToUint(wh.x));
			atomicCounterMinARB(resolution_min[1], floatBitsToUint(wh.y));
			atomicCounterMaxARB(resolution_max[0], floatBitsToUint(wh.x));
			atomicCounterMaxARB(resolution_max[1], floatBitsToUint(wh.y));
		}
	}
}

/////////////
// PROGRAM //
/////////////

pass pass_shadowmap {
	// attach shaders
	vert vs_shadowmap

	// render to
	fragout out_shadowmap
	
	// OpenGL calls
	glCullFace Front
	glClear depthBit
	glEnable depthTest
	glEnable CullFace

	// execute camera code
	exec cs_light
	
	// draw cube
	draw buf_idx in_vert ushort triangles 0 0 36
	draw buf_idx in_vert ushort triangles 8 36 6
}

pass pass_render {
	// attach shaders
	vert vs_simple
	frag fs_simple
	
	tex tex_shadowmap 0
	atomic buf_resolution_min 0 mem_clear_min
	atomic buf_resolution_max 2 mem_clear_max
	
	// OpenGL calls
	glCullFace Back
	glClearColor 0.1 0.3 1.0 0.0
	glClear colorDepthBit

	// execute camera code
	exec cs_camera
	exec cs_light
	
	// draw cube
	draw buf_idx in_vert ushort triangles 0 0 36
	draw buf_idx in_vert ushort triangles 8 36 6
}

pass pass_reset {
	tex 0 // unbind
	atomic 0
	glClearColor 0.0 0.0 0.0 0.0
	glDisable depthTest
	glDisable CullFace
}

tech tech_simple {
	pass pass_shadowmap
	pass pass_render
	pass pass_reset
}