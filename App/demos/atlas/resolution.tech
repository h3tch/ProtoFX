// AUTHOR: Michael Hecher

csharp cs_util {
	file "<csharp>/StaticCamera.cs" ...
	     "<csharp>/SimpleCamera.cs" ...
	     "<csharp>/SpotLight.cs" ...
	     "<csharp>/UniformBlock.cs" ...
	     "<csharp>/PoissonDisc.cs" ...
	     "<csharp>/CsObject.cs"
}

/////////////
// BUFFERS //
/////////////

memory mem_clear_min {
	xml "scene.xml" data/number/uint_max
}

memory mem_clear_max {
	xml "scene.xml" data/number/uint_zero
}

buffer buff_pos {
	target array
	usage staticDraw
	xml "../geom/cube.xml" data/position
	xml "../geom/plane.xml" data/position
}

buffer buff_color {
	target array
	usage staticDraw
	xml "../geom/cube.xml" data/color
	xml "../geom/plane.xml" data/color
}

buffer buf_idx {
	target element
	usage staticDraw
	xml "../geom/cube.xml" data/index
	xml "../geom/plane.xml" data/index
}

buffer buf_resolution_min {
	target atomic
	usage staticDraw
	size 8
}

buffer buf_resolution_max {
	target atomic
	usage staticDraw
	size 8
}

image img_shadowmap {
	size 128 128
	format depth32f
}

/////////////////////
// BUFFER BINDINGS //
/////////////////////

vertinput in_vert {
	attr buff_pos float 4
	attr buff_color float 4
}

sampler samp_linear {
	minfilter linear
	magfilter linear
}

fragoutput out_shadowmap {
	depth img_shadowmap
}

texture tex_shadowmap {
	img img_shadowmap
}

//////////////
// CONTROLS //
//////////////

instance cs_light {
	class cs_util camera.SpotLight
	name SpotLight
	pos 3 4 3
	rot -45 45 0
	near 4
	far 20
	radius 0.5
}

instance cs_camera {
	class cs_util camera.SimpleCamera
	name SimpleCamera
	pos -5 4 10
	rot -20 -15 0
}

instance cs_poisson {
	class cs_util sampling.PoissonDisc
	name PoissonDisc
	minRadius 0.2
}

/////////////
// SHADERS //
/////////////

shader vs_shadowmap vert {
	#version 440
	
	layout(binding = 0) uniform SpotLight {
		mat4 viewProj;
		vec4 camera;
		vec4 light;
	} light;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 in_pos;

	out gl_PerVertex {
		vec4 gl_Position;
	};
	
	void main ()
	{
		// transform vertex to light projection space
		gl_Position = light.viewProj * in_pos;
	}
}

shader vs_simple vert {
	#version 450
	
	layout(binding = 0) uniform SpotLight {
		mat4 viewProj;
		vec4 camera;
		vec4 light;
	} light;
	
	layout(binding = 1) uniform SimpleCamera {
		mat4 viewProj;
	} camera;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 in_pos;
	layout(location = 1) in vec4 in_col;

	// vertex shader output
	layout(location = 0) out vec3 out_wpos;
	layout(location = 1) out vec4 out_lpos;
	layout(location = 2) out vec4 out_col;
	out gl_PerVertex {
		vec4 gl_Position;
	};
	
	void main ()
	{
		// transform vertex to camera projection space
		gl_Position = camera.viewProj * in_pos;
		// transform vertex to light projection space
		out_lpos = light.viewProj * in_pos;
		// pass vertex color
		out_col = in_col;
		out_wpos = in_pos.xyz;
	}
}

shader fs_simple frag {
	#version 450
	//#extension GL_ARB_shader_atomic_counter_ops : require
	const float PI = 3.14159265358979;
	const float bias = 0.0003;
	const int numPoints = global.cs_poisson.NumPoints;
	
	#fold SAMPLERS
	layout(binding = 0) uniform sampler2D shadowmap;
	#endfold
	
	#fold UNIFORMS
	layout(binding = 0) uniform SpotLight {
		mat4 viewProj;
		vec4 camera;
		vec4 light;
	} light;
	
	layout(binding = 2) uniform PoissonDisc {
		vec2 points[numPoints];
		float distances[numPoints*numPoints];
		int indices[numPoints*numPoints];
	} disc;
	#endfold
	
	#fold VARYINGS
	layout(location = 0) in vec3 in_wpos;
	layout(location = 1) in vec4 in_lpos;
	layout(location = 2) in vec4 in_col;
	out vec4 color;
	#endfold
	
	#fold GLOBAL CONSTANTS
	const float zNear = light.camera.z;
	const float zFar = light.camera.w;
	const float lightR = light.light.y;
	const vec2 lightPlaneSize = light.light.zw;
	#endfold
	
	#fold FUNCTIONS
	float rand(vec2 xy) {
		return fract(sin(dot(xy, vec2(12.9898,78.233))) * 43758.5453);
	}

	mat2 randRot(float angle) {
		float sa = sin(angle);
		float ca = cos(angle);
		return mat2(ca, -sa, sa, ca);
	}
	
	vec2 depthGradient(vec3 lpos)
	{
		vec2 dz_duv;
		vec3 duvdist_dx = dFdx(lpos);
		vec3 duvdist_dy = dFdy(lpos);

		dz_duv.x = duvdist_dy.y * duvdist_dx.z;
		dz_duv.x -= duvdist_dx.y * duvdist_dy.z;

		dz_duv.y = duvdist_dx.x * duvdist_dy.z;
		dz_duv.y -= duvdist_dy.x * duvdist_dx.z;

		dz_duv /= (duvdist_dx.x * duvdist_dy.y) - (duvdist_dx.y * duvdist_dy.x);

		return dz_duv;
	}
	
	vec2 shadowMapPixelSize()
	{
		vec3 dx = dFdx(in_wpos);
		vec3 dy = dFdy(in_wpos);
		
		vec3 p[4];
		p[0] = in_wpos;
		p[1] = p[0] + dx;
		p[2] = p[0] + dy;
		p[3] = p[1] + dy;
		
		for (int i = 0; i < 4; i++) 
		{
			vec4 v = light.viewProj * vec4(p[i], 1.0);
			p[i] = (v.xyz / v.w) * 0.5 + 0.5;
		}
		
		vec2 wh = max(max(p[0], p[1]), max(p[2], p[3])).xy;
		wh -= min(min(p[0], p[1]), min(p[2], p[3])).xy;
		return wh;
	}
	
	float light2plane(float value, float zReceiver) {
		return value / zReceiver * (zReceiver - zNear);
	}

	vec2 plane2tex(float value) {
		return vec2(value) / lightPlaneSize;
	}

	float light2penumbra(float value, float zBlocker, float zReceiver) {
		return value * (zReceiver - zBlocker) / zBlocker;
	}

	float penumbra2plane(float value, float zReceiver) {
		return value * zNear / zReceiver;
	}
	
	float exp2linDepth(float z) {
		return zFar*zNear / (zFar + z * (zNear-zFar));
	}
	#endfold

	#fold PCSS
	float BlockerSearch(vec2 filterR, vec3 lpos, vec2 grad) {
		int nBlocker = 0;
		float zBlocker = 0.0;
		mat2 R = randRot(2 * PI * rand(lpos.xy));

		for (int i = 0; i < numPoints; i++) {
			vec2 uvoffset = R * disc.points[i] * filterR;
			float view_z = lpos.z + dot(grad, uvoffset) - bias;
			float light_z = texture(shadowmap, lpos.xy + uvoffset).x;
			if (view_z > light_z) {
				//zBlocker += exp2linDepth(light_z);
				zBlocker += light_z;
				nBlocker++;
			}
		}
		return exp2linDepth(zBlocker / float(nBlocker));
	}

	float PCF(vec2 filterR, vec3 lpos, vec2 grad) {
		// PCF SHADOW MAPPING
		int shadow = 0;
		mat2 R = randRot(2 * PI * rand(lpos.xy));

		for (int i = 0; i < numPoints; i++) {
			vec2 uvoffset = R * disc.points[i] * filterR;
			float view_z = lpos.z + dot(grad, uvoffset) - bias;
			float light_z = texture(shadowmap, lpos.xy + uvoffset).x;
			shadow += int(view_z > light_z);
		}

		return shadow / float(numPoints);
	}

	float PCSS(vec2 grad, vec3 lpos) {
		float receiverZ = exp2linDepth(lpos.z);
		
		// BLOCKER SEARCH
		float planeR = light2plane(lightR, receiverZ);
		vec2 filterR = plane2tex(planeR);
		float zBlocker = BlockerSearch(filterR, lpos, grad);
		if (isnan(zBlocker))
			return 0;

		// PCF SHADOW MAPPING
		float penumbraR = light2penumbra(lightR, zBlocker, receiverZ);
		planeR = penumbra2plane(penumbraR, receiverZ);
		filterR = plane2tex(planeR);
		return PCF(filterR, lpos, grad);
	}
	#endfold
	
	void main ()
	{
		color = in_col;
		
		// if pixel outside light frustum clip space, do nothing
		if (any(greaterThan(abs(in_lpos), in_lpos.wwww)))
			return;
			
		// SHADOW MAPPING
		
		// transform to normalized device coordinates [-1;+1]
		// and then to shadow map texture coordinates [0;1]
		vec3 lpos = (in_lpos.xyz / in_lpos.w) * 0.5 + 0.5;
		vec2 grad = depthGradient(lpos);
		
		float receiverZ = exp2linDepth(lpos.z);
		vec2 searchR = plane2tex(light2plane(lightR, receiverZ));
		float blockerZ = BlockerSearch(searchR, lpos, grad);
		if (isnan(blockerZ))
			return;
		float penumbraR = light2penumbra(lightR, blockerZ, receiverZ);
		vec2 filterR = plane2tex(penumbra2plane(penumbraR, receiverZ));
		float shadow = PCF(filterR, lpos, grad);
		color = vec4(1 - shadow);
		
		//const float r = 3.4;
		//vec2 discSize = r / shadowmapResolution;
		/*vec2 wh = shadowMapPixelSize();
		
		if (shadow == 0)
			return;
		
		if (shadow == 1.0)
		{
			color = vec4(0);
			return;
		}
		
		float percent = 1 - shadow;
		vec2 shadowmapResolution = textureSize(shadowmap, 0).xy;
		vec2 shadowmapScale = 0.5 / shadowmapResolution / wh;
		float scale = max(shadowmapScale.x, shadowmapScale.y);
		if (scale > 1)
			percent = clamp((percent * 2 - 1) * scale, -1, 1) * 0.5 + 0.5;
		color *= percent;*/
	}
}

/////////////
// PROGRAM //
/////////////

pass pass_shadowmap {
	// attach shaders
	vert vs_shadowmap

	// render to
	fragout out_shadowmap
	
	// OpenGL calls
	//glCullFace Front
	glClear depthBit
	glEnable depthTest
	glEnable CullFace

	// execute camera code
	exec cs_light
	
	// draw cube
	draw buf_idx in_vert ushort triangles 0 0 36
	draw buf_idx in_vert ushort triangles 8 36 6
}

pass pass_render {
	// attach shaders
	vert vs_simple
	frag fs_simple
	
	tex tex_shadowmap 0
	atomic buf_resolution_min 0 mem_clear_min
	atomic buf_resolution_max 2 mem_clear_max
	
	// OpenGL calls
	//glCullFace Back
	glClearColor 0.1 0.3 1.0 0.0
	glClear colorDepthBit

	// execute camera code
	exec cs_camera
	exec cs_light
	exec cs_poisson
	
	// draw cube
	draw buf_idx in_vert ushort triangles 0 0 36
	draw buf_idx in_vert ushort triangles 8 36 6
}

pass pass_reset {
	tex 0 // unbind
	atomic 0
	glClearColor 0.0 0.0 0.0 0.0
	glDisable depthTest
	glDisable CullFace
}

tech tech_simple {
	pass pass_shadowmap
	pass pass_render
	pass pass_reset
}