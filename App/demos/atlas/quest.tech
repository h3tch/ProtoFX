#global RESOLUTION 2048
#global HALF_RESOLUTION 1024
#global PI 3.14159265359

csharp cs {
	assembly "Interop.MLApp.dll"
	file "<csharp>/ArtifactQuest.cs" ...
	     "<csharp>/UniformBlock.cs" ...
	     "<csharp>/CsObject.cs" ...
	     "<csharp>/Converter.cs"
}

instance cs_quest {
	class cs csharp.ArtifactQuest
	name QuestSetup
}

// FULL SCREEN QUAD
text xml_quad {
	<?xml version='1.0'?>
	<data>
		<position type='float' isbinary='false'>
			-1.0 -1.0  0.0  1.0
			 1.0 -1.0  0.0  1.0
			 1.0  1.0  0.0  1.0
			-1.0  1.0  0.0  1.0
			-1.0 -1.0  0.0  1.0
			 1.0 -1.0  0.0  1.0
			 1.0  1.0  0.0  1.0
			-1.0  1.0  0.0  1.0
		</position>
		<index type='ushort' isbinary='false'>
			0  1  2
			2  3  0
		</index>
	</data>
}

buffer buf_pos {
	usage staticDraw
	xml xml_quad data/position
}

buffer buf_idx {
	usage staticDraw
	xml xml_quad data/index
}

vertinput in_vert {
	attr buf_pos float 4
}

image img_artifact {
	size RESOLUTION RESOLUTION
	format r32f
}

image img_filterX {
	size HALF_RESOLUTION RESOLUTION
	format r32f
}

image img_filterY {
	size HALF_RESOLUTION HALF_RESOLUTION
	format r32f
}

sampler samp_linear {
	minfilter linear
	magfilter linear
}

texture tex_artifact {
	img img_artifact
}

texture tex_filterX {
	img img_filterX
}

texture tex_filterY {
	img img_filterY
}

fragoutput out_artifact {
	color img_artifact
}

fragoutput out_filterX {
	color img_filterX
}

fragoutput out_filterY {
	color img_filterY
}

shader vert vs_shader {
	#version 450
	
	layout(location = 0) in vec4 position;
	
	void main() {
		gl_Position = position;
	}
}

shader frag fs_artifact {
	#version 450
	
	precision highp float;
	
	const ivec2 resolutionArtifact = ivec2(RESOLUTION);
	const ivec2 resolutionFilterX = ivec2(HALF_RESOLUTION, RESOLUTION);
	const ivec2 resolutionFilterY = ivec2(HALF_RESOLUTION);
	
	layout(binding = 0, std140) uniform QuestSetup {
		layout(offset = 0) ivec2 resolutionFramebuffer;
		layout(offset = 8) float lineAngle;
		layout(offset = 12) float lineDist;
		layout(offset = 16) float randomAngle;
		layout(offset = 20) int artifactSize;
		layout(offset = 24) int filterRadius;
	} setup;
	
	layout(pixel_center_integer) in vec4 gl_FragCoord;
	
	out vec4 color;
	
	/*// returns the positive root of intersection of line y = h
	// with circle centered at the origin and radius r
	float section(float h, float r) {
		return (h < r) ? sqrt(r * r - h * h) : 0;
	}

	// indefinite integral of circle segment
	float circleSegIntegral(float x, float h, float r) {
		return 0.5 * (sqrt(1 - x * x / (r * r)) * x * r + r * r * asin(x / r) - 2 * h * x);
	}
	
	// area of intersection of an infinitely tall box with left edge at x0,
	// right edge at x1, bottom edge at h and top edge at infinity, with
	// circle centered at the origin with radius r
	//float area2(float x0, float x1, float h, float r) {
	//	// this must be sorted otherwise we get negative area
	//	if(x0 > x1)
	//	{
	//		float x = x0;
	//		x0 = x1;
	//		x1 = x;
	//	}
	//	float s = section(h, r);
	//	// integrate the area
	//	return circleSegIntegral(max(-s, min(s, x1)), h, r) - circleSegIntegral(max(-s, min(s, x0)), h, r);
	//}
	float circleSegArea(vec2 x, float h, float r) {
		// this must be sorted otherwise we get a negative area
		float s = section(h, r);
		x = clamp(x, -s, s);
		// integrate the area
		return circleSegIntegral(x.y, h, r) - circleSegIntegral(x.x, h, r);
	}

	// area of the intersection of a finite box with a
	// circle centered at the origin with radius r
	//float area(float x0, float x1, float y0, float y1, float r) {
	//	// this will simplify the reasoning
	//	if(y0 > y1)
	//	{
	//		float y = y0;
	//		y0 = y1;
	//		y1 = y;
	//	}
	//	// area of the lower box minus area of the higher box
	//	return area2(x0, x1, y0, r) - area2(x0, x1, y1, r);
	//}
	float area(vec2 x, vec2 y, float r) {
		// area of the lower box minus area of the higher box
		return circleSegArea(x, y.x, r) - circleSegArea(x, y.y, r);
	}
	

	// area of the intersection of a finite box with a
	// circle centered at the origin with radius r
	//float selectCase(float x0, float x1, float y0, float y1, float r) {
	//	// this will simplify the reasoning
	//	if(y0 > y1)
	//	{
	//		float y = y0;
	//		y0 = y1;
	//		y1 = y;
	//	}
	//	if(y0 < 0) {
	//		if(y1 < 0)
	//			// the box is completely under, just flip it above and try again
	//			return area(x0, x1, -y0, -y1, r);
	//		else
	//			// the box is both above and below, divide it to two boxes and go again
	//			return area(x0, x1, 0, -y0, r) + area(x0, x1, 0, y1, r);
	//	} else
	//		// area of the lower box minus area of the higher box
	//		return area(x0, x1, y0, y1, r);
	//}
	float selectCase(vec2 x, vec2 y, float r) {
		if(y.x < 0) {
			if(y.y < 0)
				// the box is completely under, just flip it above and try again
				return area(x, -y.yx, r);
			else
				// the box is both above and below, divide it to two boxes and go again
				return area(x, vec2(0, -y.x), r) + area(x, vec2(0, y.y), r);
		} else
			// area of the lower box minus area of the higher box
			return area(x, y, r);
	}
	

	// area of the intersection of a general box with a general circle
	//float sampleArtifact(float x0, float x1, float y0, float y1, float cx, float cy, float r)
	//{
	//	x0 -= cx;
	//	x1 -= cx;
	//	y0 -= cy;
	//	y1 -= cy;
	//	// get rid of the circle center
	//	return selectCase(x0, x1, y0, y1, r);
	//}
	float areaRectCircle(vec4 rect, vec2 c, float r)
	{
		// get rid of the circle center
		rect -= c.xxyy;
		return selectCase(rect.xy, rect.zw, r);
	}
	
	//float sampleArtifact(ivec2 pos, vec3 hesseLine) {
	//	pos = pos / setup.artifactSize * setup.artifactSize;
	//	return dot(vec2(pos), hesseLine.xy) < hesseLine.z ? 0 : 1;
	//}*/
	float circleSegAreaDefault(float h, float r) {
		return r * r * acos(1 - h / r) - (r - h) * sqrt(2*r*h - h*h);
	}
	
	float circleSegArea(float h, float r) {
		if (h <= -r)
			return 0;
		if (h >= r)
			return PI * r * r;
		if (h < 0)
		{
			h = r + h;
			return circleSegAreaDefault(h, r);
		}
		else
		{
			h = r - h;
			return (PI * r * r) - circleSegAreaDefault(h, r);
		}
	}
	
	void main() {
		float filterRadius = 300.0;
		float artifactSize = 50.0;
		int <<a>> = int((gl_FragCoord.x - filterRadius) / artifactSize) - 1;
		int <<b>> = int((gl_FragCoord.x + filterRadius) / artifactSize);
		float areaCircle = filterRadius * filterRadius * PI;
		float areaRect = 0;
		
		while (a <= b) {
			vec2 <<x>> = vec2(float(a), float(a+1)) * artifactSize;
			vec2 <<y>> = vec2(-filterRadius*2, x.x);
			float A = area(x.x, x.y, y.x, y.y, gl_FragCoord.x, gl_FragCoord.y, filterRadius);
			if (isnan(A)) {
				vec2 <<C>> = gl_FragCoord.xy;
				vec4 <<rect>> = vec4(x, y);
			} else
				areaRect += A;
			a++;
		}
		
		color.xyzw = vec4(<<areaRect>> / <<areaCircle>>);
		
		//vec3 hesseLine = vec3(cos(setup.lineAngle), sin(setup.lineAngle), setup.lineDist);
		//              
		//color = sampleArtifact(ivec2(gl_FragCoord.xy), hesseLine);
	}
}

shader frag fs_filterX {
	#version 450
	
	const ivec2 resolutionArtifact = ivec2(RESOLUTION);
	const ivec2 resolutionFilterX = ivec2(HALF_RESOLUTION, RESOLUTION);
	const ivec2 resolutionFilterY = ivec2(HALF_RESOLUTION);
	
	layout(binding = 0, std140) uniform QuestSetup {
		layout(offset = 0) ivec2 resolutionFramebuffer;
		layout(offset = 8) float lineAngle;
		layout(offset = 12) float lineDist;
		layout(offset = 16) float randomAngle;
		layout(offset = 20) int artifactSize;
		layout(offset = 24) int filterRadius;
	} setup;
	
	layout(binding = 0) uniform sampler2D artifacts;
	
	layout(pixel_center_integer) in vec4 gl_FragCoord;
	
	out float color;
	
	void main() {
		vec2 offset = (textureSize(artifacts, 0).xy - resolutionFilterX) / 2;
		ivec2 center = ivec2(offset + gl_FragCoord.xy);
		
		float I = 0;
		int C = 0;
		for (int i = -setup.filterRadius; i <= setup.filterRadius; i++)
		{
			I += texelFetch(artifacts, center + ivec2(i, 0), 0).x;
			C ++;
		}
			
		color = float(I / C);
		//color = texelFetch(artifacts, center, 0).x;
	}
}

shader frag fs_filterY {
	#version 450
	
	const ivec2 resolutionArtifact = ivec2(RESOLUTION);
	const ivec2 resolutionFilterX = ivec2(HALF_RESOLUTION, RESOLUTION);
	const ivec2 resolutionFilterY = ivec2(HALF_RESOLUTION);
	
	layout(binding = 0, std140) uniform QuestSetup {
		layout(offset = 0) ivec2 resolutionFramebuffer;
		layout(offset = 8) float lineAngle;
		layout(offset = 12) float lineDist;
		layout(offset = 16) float randomAngle;
		layout(offset = 20) int artifactSize;
		layout(offset = 24) int filterRadius;
	} setup;
	
	layout(binding = 0) uniform sampler2D filterX;
	
	layout(pixel_center_integer) in vec4 gl_FragCoord;
	
	out float color;
	
	void main() {
		vec2 offset = (textureSize(filterX, 0).xy - resolutionFilterY) / 2;
		ivec2 center = ivec2(offset + gl_FragCoord.xy);
		
		float I = 0;
		int C = 0;
		for (int i = -setup.filterRadius; i <= setup.filterRadius; i++) {
			I += texelFetch(filterX, center + ivec2(0, i), 0).x;
			C ++;
		}
			
		color = float(I / C);
		//color = texelFetch(filterX, center, 0).x;
	}
}

shader frag fs_render {
	#version 450
	
	const ivec2 resolutionFilterY = ivec2(HALF_RESOLUTION);
	
	layout(binding = 0, std140) uniform QuestSetup {
		layout(offset = 0) ivec2 resolutionFramebuffer;
		layout(offset = 8) float lineAngle;
		layout(offset = 12) float lineDist;
		layout(offset = 16) float randomAngle;
		layout(offset = 20) int artifactSize;
		layout(offset = 24) int filterRadius;
	} setup;
	
	layout(binding = 0) uniform sampler2D filterY;
	
	layout(pixel_center_integer) in vec4 gl_FragCoord;
	
	out vec4 color;
	
	void main() {
		mat2 M = mat2(vec2( cos(setup.randomAngle), sin(setup.randomAngle)),
		              vec2(-sin(setup.randomAngle), cos(setup.randomAngle)));
		vec2 coord = gl_FragCoord.xy / setup.resolutionFramebuffer - 0.5;
		coord = (coord * setup.resolutionFramebuffer / resolutionFilterY) * M + 0.5;
		color = texture(filterY, coord).xxxx;
	}
}

pass pass_artifact {
	vert vs_shader
	frag fs_artifact
	//fragout out_artifact
	
	tex 0
	samp 0
	
	glClear ColorBit
	
	draw buf_idx in_vert ushort triangles 0 0 6
	
	//exec cs_quest
}

pass pass_filterX {
	vert vs_shader
	frag fs_filterX
	fragout out_filterX
	
	tex tex_artifact 0
	
	glClear ColorBit
	
	draw buf_idx in_vert ushort triangles 0 0 6
}

pass pass_filterY {
	vert vs_shader
	frag fs_filterY
	fragout out_filterY
	
	tex tex_filterX 0
	
	glClear ColorBit
	
	draw buf_idx in_vert ushort triangles 0 0 6
}

pass pass_render {
	vert vs_shader
	frag fs_render
	
	tex tex_filterY 0
	samp samp_linear 0
	
	glClear ColorBit
	
	draw buf_idx in_vert ushort triangles 0 0 6
}

tech tech_quest {
	pass pass_artifact
	//pass pass_filterX
	//pass pass_filterY
	//pass pass_render
}