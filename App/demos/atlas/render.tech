// custurm clipping test

// global variables
#global MAX_CAMS 4

//////////////////
// DATA OBJECTS //
//////////////////

// DRAW INFORMATION

buffer draw_calls {
	usage staticDraw
	xml "scene.xml" data/drawcall
}

// CAMERA INFORMATION

buffer camera_transform {
	usage staticDraw
	xml "scene.xml" data/camera/transform
}

buffer camera_viewport {
	usage staticDraw
	xml "scene.xml" data/camera/viewport
}

// OBJECT INFORMATION

buffer object_transform {
	usage staticDraw
	xml "scene.xml" data/object/transform
}

buffer object_cameraid {
	usage staticDraw
	xml "scene.xml" data/object/cameraid
}

// VERTEX INFORMATION

buffer mesh_position {
	usage staticDraw
	xml "scene.xml" data/mesh/position
}

buffer mesh_normal {
	usage staticDraw
	xml "scene.xml" data/mesh/normal
}

buffer mesh_color {
	usage staticDraw
	xml "scene.xml" data/mesh/color
}

buffer mesh_triangles {
	usage staticDraw
	xml "scene.xml" data/mesh/triangles
}

// RENDER BUFFERS

image img_depth {
	width 1024
	height 768
	format depth32f
}

/////////////////////////
// DATA FORMAT OBJECTS //
/////////////////////////

vertinput vertex_input {
	attr mesh_position float 4
	attr mesh_normal float 4
	attr mesh_color float 4
	attr object_transform float 4 48 0 1
	attr object_transform float 4 48 16 1
	attr object_transform float 4 48 32 1
	attr object_cameraid int 4 16 0 1
}

texture camera_transform_texture {
	buff camera_transform
	format RGBA32f
}

texture camera_viewport_texture {
	buff camera_viewport
	format RGBA32f
}

fragoutput fragout_shadowmap {
	depth img_depth
}

//////////////
// CONTROLS //
//////////////

csharp cs_util {
	file "<csharp>/BufferCamera.cs" ...
	     "<csharp>/UniformBlock.cs" ...
	     "<csharp>/CsObject.cs"
}

instance cs_camera {
	class cs_util csharp.BufferCamera
	buff camera_transform 0
	pos -5 4 10
	rot -20 -15 0
}

/////////////
// SHADERS //
/////////////

// Simple GLSL vertex shader transforming
// vertex positions from model to perspective space
shader vert vs_shadowmap {
	#version 450
	
	layout(binding = 0) uniform samplerBuffer camTransform;
	layout(binding = 1) uniform samplerBuffer camViewport;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 position;
	layout(location = 3) in vec4 axisx;
	layout(location = 4) in vec4 axisy;
	layout(location = 5) in vec4 axisz;
	layout(location = 6) in ivec4 camera[(MAX_CAMS+3)/4];

	// vertex shader output
	layout(location = 0) out vec4 pos[MAX_CAMS];
	layout(location = MAX_CAMS) out vec4 vp[MAX_CAMS];
	
	void main ()
	{
		int count;
		mat4 viewProj[MAX_CAMS];
		
		// create model matrix
		mat4 <<model>> = mat4(axisx, axisy, axisz, vec4(0,0,0,1));
		
		// create view matrix for every camera
		for (count = 0; <<count>> < MAX_CAMS && camera[count / 4][count % 4] >= 0; count++)
		{
			int ptr = camera[count / 4][count % 4];
			vp[count] = texelFetch(camViewport, ptr);
			ptr *= 4;
			viewProj[count] = mat4(
				texelFetch(camTransform, ptr + 0),
				texelFetch(camTransform, ptr + 1),
				texelFetch(camTransform, ptr + 2),
				texelFetch(camTransform, ptr + 3));
		}
		
		// pass varyings on to next shader
		for (int i = count; i < MAX_CAMS; i++)
			pos[i] = vp[i] = vec4(0);
		
		// compute model view projection position
		vec4 world = position * model;
		for (int i = 0; i < count; i++)
			pos[i] = viewProj[i] * world;
	}
}

shader geom gs_shadowmap {
	#version 450
	
	layout(triangles) in;
	layout(location = 0) in vec4 position[][MAX_CAMS];
	layout(location = MAX_CAMS) in vec4 viewport[][MAX_CAMS];
	
	layout(triangle_strip, max_vertices = 3*MAX_CAMS) out;
	
	void main ()
	{
		// for each camera
		for (int c = 0; c < MAX_CAMS && position[0][c].w != 0; c++)
		{
			// for each vertex in the triangle
			for (int v = 0; v < gl_in.length(); v++)
			{
				vec4 <<pos>> = position[v][c];
				vec4 <<vp>> = viewport[v][c];
				
				// viewport clipping
				gl_ClipDistance[0] = pos.w - pos.x;
				gl_ClipDistance[1] = pos.x + pos.w;
				gl_ClipDistance[2] = pos.w - pos.y;
				gl_ClipDistance[3] = pos.y + pos.w;
				
				// viewport transform
				pos.xy /= pos.w;
				pos.xy = pos.xy * 0.5 + 0.5;
				pos.xy = pos.xy * vp.zw + vp.xy;
				pos.xy = pos.xy * 2.0 - 1.0;
				pos.xy *= pos.w;
				
				// geomitry shader output
				gl_Position = <<pos>>;
				EmitVertex();
			}
			EndPrimitive();
		}
	}
}

shader vert vs_render {
	#version 450
	
	layout(binding = 0) uniform samplerBuffer camTransform;
	layout(binding = 1) uniform samplerBuffer camViewport;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 position;
	layout(location = 1) in vec4 normal;
	layout(location = 2) in vec4 color;
	layout(location = 3) in vec4 axisx;
	layout(location = 4) in vec4 axisy;
	layout(location = 5) in vec4 axisz;

	// vertex shader output
	layout(location = 0) out vec4 nor;
	layout(location = 1) out vec4 col;
	
	void main ()
	{
		// create model matrix
		mat4 <<model>> = mat4(axisx, axisy, axisz, vec4(0,0,0,1));
		
		// create view matrix for the camera
		mat4 viewProj[count] = mat4(
			texelFetch(camTransform, 0),
			texelFetch(camTransform, 1),
			texelFetch(camTransform, 2),
			texelFetch(camTransform, 3));
			
		nor = normal;
		col = color;
		gl_Position = viewProj[i] * (position * model);
	}
}

// Simple GLSL fragment shader writing
// the color of the fragment to the framebuffer
shader frag fs_render {
	#version 450
	
	// fragment shader input (see col in vs_simple)
	layout(location = 0) in vec4 color;
	layout(location = 1) in vec4 normal;
	
	// fragment color output
	out vec4 col;
	
	void main ()
	{
		col = <<color>>;
	}
}

/////////////////
// RENDER PASS //
/////////////////

// Define a rendering pass
pass pass_shadowmap {
	// ATTATCH SHADERS
	vert vs_shadowmap
	geom gs_shadowmap
	frag fs_simple
	
	fragout fragout_shadowmap
	
	tex camera_transform_texture 0
	tex camera_viewport_texture 1
	
	// OPENGL FUNCTIONS
	glClear DepthBit
	glEnable depthTest
	glEnable clipDistance0
	glEnable clipDistance1
	glEnable clipDistance2
	glEnable clipDistance3
	
	// DRAW CALLS
	draw mesh_triangles vertex_input ushort triangles draw_calls
	
	exec cs_camera
}

// Define a rendering pass
pass pass_render {
	// ATTATCH SHADERS
	vert vs_render
	frag fs_render
	
	fragout fragout_shadowmap
	
	tex camera_transform_texture 0
	tex camera_viewport_texture 1
	
	// OPENGL FUNCTIONS
	// set clear color
	glClearColor 0.1 0.3 1.0 0.0
	// clear color and depth buffer
	glClear ColorDepthBit
	// enable depth buffer test
	glEnable depthTest
	
	glEnable clipDistance0
	glEnable clipDistance1
	glEnable clipDistance2
	glEnable clipDistance3
	
	// DRAW CALLS
	draw mesh_triangles vertex_input ushort triangles draw_calls
	
	exec cs_camera
}

pass pass_reset {
	glDisable clipDistance0
	glDisable clipDistance1
	glDisable clipDistance2
	glDisable clipDistance3
}

///////////////
// TECHNIQUE //
///////////////

// Combine passes into a single technique.
// In this case we only have one pass.
tech tech_simple {
	// First pass
	pass pass_render
	pass pass_reset
}