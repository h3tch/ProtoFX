// custurm clipping test

//////////////////
// DATA OBJECTS //
//////////////////

// DRAW INFORMATION

buffer draw_calls {
	usage staticDraw
	xml "scene.xml" data/drawcalls
}

// CAMERA INFORMATION

buffer camera_transform {
	usage staticDraw
	xml "scene.xml" data/camera/transform
}

buffer camera_viewport {
	usage staticDraw
	xml "scene.xml" data/camera/viewport
}

// OBJECT INFORMATION

buffer object_transform {
	usage staticDraw
	xml "scene.xml" data/object/transform
}

buffer object_cameraid {
	usage staticDraw
	xml "scene.xml" data/object/cameraid
}

// VERTEX INFORMATION

buffer mesh_position {
	usage staticDraw
	xml "scene.xml" data/mesh/position
}

buffer mesh_normal {
	usage staticDraw
	xml "scene.xml" data/mesh/normal
}

buffer mesh_color {
	usage staticDraw
	xml "scene.xml" data/mesh/color
}

buffer mesh_triangles {
	usage staticDraw
	xml "scene.xml" data/mesh/triangles
}

/////////////////////////
// DATA FORMAT OBJECTS //
/////////////////////////

vertinput vertex_input {
	attr mesh_position float 4
	attr mesh_normal float 4
	attr mesh_color float 4
	attr object_transform float 4 48 0 1
	attr object_transform float 4 48 16 1
	attr object_transform float 4 48 32 1
	attr object_cameraid float 4 16 0 1
}

texture camera_transform_texture {
	buff camera_transform
}

texture camera_viewport_texture {
	buff camera_viewport
}

/////////////
// SHADERS //
/////////////

// Simple GLSL vertex shader transforming
// vertex positions from model to perspective space
shader vert vs_simple {
	#version 450
	
	layout(binding = 0) uniform sampler1D camTransform;
	layout(binding = 1) uniform sampler1D camViewport;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 position;
	layout(location = 1) in vec4 normal;
	layout(location = 3) in vec4 color;
	layout(location = 4) in vec4 axisx;
	layout(location = 5) in vec4 axisy;
	layout(location = 6) in vec4 axisz;
	layout(location = 7) in ivec4 camera;

	// vertex shader output
	layout(location = 0) out vec4 col;
	layout(location = 1) out vec4 nor;
	layout(location = 2) out vec4 pos[4];
	layout(location = 3) out vec4 vp[4];
	
	void main ()
	{
		int count;
		mat4 viewProj[4];
		
		// create model matrix
		mat4 model = mat4(axisx, axisy, axisz, vec4(0,0,0,1));
		
		// create view matrix for every camera
		for (count = 0; count < 4 && camera[count] >= 0; count++)
		{
			int ptr = 4 * camera[count];
			viewProj[count] = mat4(
				texelFetchOffset(camTransform, ptr, 0, 0),
				texelFetchOffset(camTransform, ptr, 0, 1),
				texelFetchOffset(camTransform, ptr, 0, 2),
				texelFetchOffset(camTransform, ptr, 0, 3));
			vp[count] = texelFetch(camViewport, ptr);
		}
		
		// pass varyings on to next shader
		col = color;
		nor = normal;
		for (int i = count; i < 4; i++)
		{
			pos[i] = vec4(0);
			vp[i] = vec4(0);
		}
		
		// compute model view projection position
		vec4 word = model * position;
		for (int i = 0; i < count; i++)
			pos[i] = viewProj[i] * word;
	}
}

shader geom gs_simple {
	#version 450
	
	layout(triangles) in;
	in IN
	{
		layout(location = 0) in vec4 color;
		layout(location = 1) in vec4 normal;
		layout(location = 2) in vec4 position[4];
		layout(location = 3) in vec4 viewport[4];
	} In[];
	
	layout(triangle_strip, max_vertices = 12) out;
	layout(location = 0) out vec4 color;
	layout(location = 1) out vec4 normal;
	
	out gl_PerVertex {
		float gl_CullDistance[4];
	};
	
	void main ()
	{
		for (int c = 0; c < 4 && In[0].position[c].w != 0; c++)
		{
			for (int v = 0; v < gl_in.length(); v++)
			{
				gl_Position = In[v].position[c];
				normal = In[v].normal;
				color = In[v].color;
				
				// viewport culling
				vec4 vp = gl_Position.xyxy / gl_Position.w * 0.5 + 0.5;
				vp = (vp - In[v].viewport[c]) * vec4(1,1,-1,-1);
				gl_CullDistance[0] = vp.x;
				gl_CullDistance[1] = vp.y;
				gl_CullDistance[2] = vp.z;
				gl_CullDistance[3] = vp.w;
				
				EmitVertex();
			}
			EndPrimitive();
		}
	}
}

// Simple GLSL fragment shader writing
// the color of the fragment to the framebuffer
shader frag fs_simple {
	#version 450
	
	// fragment shader input (see col in vs_simple)
	in IN
	{
		layout(location = 0) in vec4 color;
		layout(location = 1) in vec4 normal;
	} In;
	
	// fragment color output
	out vec4 color;
	
	void main ()
	{
		color = <<In.color>>;
	}
}

//////////////
// CONTROLS //
//////////////

// Include C# code to allow
// for simple camera controls
csharp cs_util {
	// Compile C# file "SimpleCamera.cs"
	file "<csharp>/StaticCamera.cs" ...
	     "<csharp>/SimpleCamera.cs" ...
	     "<csharp>/UniformBlock.cs"
}

instance cs_camera {
	class cs_util csharp.SimpleCamera
	name SimpleCamera
	pos -5 4 10
	rot -20 -15 0
}

/////////////////
// RENDER PASS //
/////////////////

// Define a rendering pass
pass pass_render {
	// ATTATCH SHADERS
	vert vs_simple
	geom gs_simple
	frag fs_simple
	
	tex camera_transform_texture 0
	tex camera_viewport_texture 1
	
	// OPENGL FUNCTIONS
	// set clear color
	ClearColor 0.1 0.3 1.0 0.0
	// clear color and depth buffer
	Clear ColorDepthBit
	// enable depth buffer test
	Enable depthTest
	
	// EXECUTE CONTROL
	// execute camera code (sets g_viewproj in vs_simple)
	exec cs_camera
	
	// DRAW CALLS
	draw mesh_triangles vertex_input ushort triangles draw_calls
}

///////////////
// TECHNIQUE //
///////////////

// Combine passes into a single technique.
// In this case we only have one pass.
tech tech_simple {
	// First pass
	pass pass_render
}