// AUTHOR: Michael Hecher

csharp cs_util {
	file "<csharp>/StaticCamera.cs" ...
	     "<csharp>/SimpleCamera.cs" ...
	     "<csharp>/UniformBlock.cs" ...
	     "<csharp>/CsObject.cs"
}

/////////////
// BUFFERS //
/////////////

buffer buff_pos {
	// buffer will only be used for reading
	// and will not be updated during runtime
	usage staticDraw
	// load <pos></pos> data from XML file
	// these are vertex positions for each vertex
	xml "geom/cube.xml" data/position
	xml "geom/plane.xml" data/position
}

buffer buff_color {
	usage staticDraw
	xml "geom/cube.xml" data/color
	xml "geom/plane.xml" data/color
}

buffer buf_idx {
	usage staticDraw
	xml "geom/cube.xml" data/index
	xml "geom/plane.xml" data/index
}

image img_shadowmap {
	// image size in pixels
	size 1024 1024
	// pixel format is a 32
	// bit floating point depth
	format depth32f
}

/////////////////////
// BUFFER BINDINGS //
/////////////////////

vertinput in_vert {
	// first attribute: floating point
	// vertex positions (x,y,z,1)
	attr buff_pos float 4
	// second attribute: floating point
	// vertex colors (x,y,z,1)
	attr buff_color float 4
}

sampler samp_linear {
	minfilter linear
	magfilter linear
}

fragoutput out_shadowmap {
	// depth attachment
	depth img_shadowmap
}

texture tex_shadowmap {
	img img_shadowmap
}

//////////////
// CONTROLS //
//////////////

instance cs_light {
	class cs_util camera.StaticCamera
	name StaticCamera
	pos 3 4 3
	rot -45 45 0
}

instance cs_camera {
	class cs_util camera.SimpleCamera
	name SimpleCamera
	pos -5 4 10
	rot -20 -15 0
}

/////////////
// SHADERS //
/////////////

shader vs_shadowmap vert {
	#version 440
	
	layout(binding = 0) uniform StaticCamera {
		mat4 viewProj;
	} light;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 in_pos;

	out gl_PerVertex {
		vec4 gl_Position;
	};
	
	void main ()
	{
		// transform vertex to light projection space
		gl_Position = light.viewProj * in_pos;
	}
}

shader vs_simple vert {
	#version 450
	
	layout(binding = 0) uniform StaticCamera {
		mat4 viewProj;
	} light;
	
	layout(binding = 1) uniform SimpleCamera {
		mat4 viewProj;
	} camera;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 in_pos;
	layout(location = 1) in vec4 in_col;

	// vertex shader output
	layout(location = 0) out vec3 out_wpos;
	layout(location = 1) out vec4 out_lpos;
	layout(location = 2) out vec4 out_col;
	out gl_PerVertex {
		vec4 gl_Position;
	};
	
	void main ()
	{
		// transform vertex to camera projection space
		gl_Position = camera.viewProj * in_pos;
		// transform vertex to light projection space
		out_lpos = light.viewProj * in_pos;
		// pass vertex color
		out_col = in_col;
		out_wpos = in_pos.xyz;
	}
}

shader gs_simple geom {
	#version 450
	
	layout(triangles) in;
	layout(location = 0) in Block {
		vec3 in_wpos;
		vec4 in_lpos;
		vec4 in_col;
	} IN[];
	in gl_PerVertex {
		vec4 gl_Position;
	} gl_in[];
	
	layout(triangle_strip, max_vertices = 3) out;
	layout(location = 0) out vec3 out_wpos;
	layout(location = 1) out vec4 out_lpos;
	layout(location = 2) out vec4 out_col;
	out gl_PerVertex {
		vec4 gl_Position;
	};
	
	void main ()
	{
		vec3 dx = IN[1].in_wpos.xyz - IN[0].in_wpos.xyz;
		vec3 dy = IN[2].in_wpos.xyz - IN[0].in_wpos.xyz;
		vec3 nor = cross(dx, dy);
		
		// for each vertex in the triangle
		for (int v = 0; v < gl_in.length(); v++)
		{
			gl_Position = gl_in[v].gl_Position;
			out_wpos = IN[v].in_wpos;
			out_lpos = IN[v].in_lpos;
			out_col = IN[v].in_col;
			EmitVertex();
		}
		EndPrimitive();
	}
}

shader fs_simple frag {
	#version 450
	
	layout(binding = 0) uniform StaticCamera {
		mat4 viewProj;
	} light;
	
	layout(binding = 0) uniform sampler2D shadowmap;
	
	layout(location = 0) in vec3 in_wpos;
	layout(location = 1) in vec4 in_lpos;
	layout(location = 2) in vec4 in_col;
	out vec4 color;
	
	layout(pixel_center_integer) in vec4 gl_FragCoord;
	
	void main ()
	{
		color = in_col;
		
		// if pixel outside light frustum clip space, do nothing
		if (any(greaterThan(abs(in_lpos), in_lpos.wwww)))
			return;
		
		vec3 dx = dFdx(in_wpos);
		vec3 dy = dFdy(in_wpos);
		
		vec3 p[4];
		p[0] = in_wpos;
		p[1] = p[0] + dx;
		p[2] = p[0] + dy;
		p[3] = p[1] + dy;
		
		for (int i = 0; i < 4; i++) 
		{
			vec4 v = light.viewProj * vec4(p[i], 1.0);
			p[i] = (v.xyz / v.w) * 0.5 + 0.5;
		}
		
		vec4 bbox;
		bbox.xy = min(min(p[0], p[1]), min(p[2], p[3])).xy;
		bbox.zw = max(max(p[0], p[1]), max(p[2], p[3])).xy;
		
		vec2 wh = bbox.zw - bbox.xy;
		
		// pass color
		color = vec4(wh * 50, 0, 1);
			
		// SHADOW MAPPING
		
		// transform to normalized device coordinates [-1;+1]
		// and then to shadow map texture coordinates [0;1]
		vec3 lpos = (in_lpos.xyz / in_lpos.w) * 0.5 + 0.5;
		
		// if pixel distance from the light source is greader than
		// the distance in the shadow map, the pixel is in shadow
		if (lpos.z-0.0005 > texture(shadowmap, lpos.xy).x)
			color.xyz *= 0.5;
	}
}

/////////////
// PROGRAM //
/////////////

pass pass_shadowmap {
	// attach shaders
	vert vs_shadowmap

	// render to
	fragout out_shadowmap
	
	// OpenGL calls
	glClear depthBit
	glEnable depthTest

	// execute camera code
	exec cs_light
	
	// draw cube
	draw buf_idx in_vert ushort triangles 0 0 36
	draw buf_idx in_vert ushort triangles 8 36 6
}

pass pass_render {
	// attach shaders
	vert vs_simple
	geom gs_simple
	frag fs_simple
	
	tex tex_shadowmap 0
	
	// OpenGL calls
	glClearColor 0.1 0.3 1.0 0.0
	glClear colorDepthBit

	// execute camera code
	exec cs_camera
	exec cs_light
	
	// draw cube
	draw buf_idx in_vert ushort triangles 0 0 36
	draw buf_idx in_vert ushort triangles 8 36 6
}

pass pass_reset {
	tex 0 // unbind
	glClearColor 0.0 0.0 0.0 0.0
	glDisable depthTest
}

tech tech_simple {
	pass pass_shadowmap
	pass pass_render
	pass pass_reset
}