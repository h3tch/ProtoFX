// AUTHOR: Michael Hecher

/////////////
// BUFFERS //
/////////////

buffer buf_pos {
	usage staticDraw
	xml "geom/cube.xml" data/position
	xml "geom/plane.xml" data/position
}

buffer buf_col {
	usage staticDraw
	xml "geom/cube.xml" data/color
	xml "geom/plane.xml" data/color
}

buffer buf_idx {
	usage staticDraw
	xml "geom/cube.xml" data/index
	xml "geom/plane.xml" data/index
}

image img_shadowmap {
	width 512
	height 512
	format depth32f
}

/////////////////////
// BUFFER BINDINGS //
/////////////////////

vertinput in_vert {
	attr buf_pos float 4
	attr buf_col float 4
}

sampler samp_linear {
	minfilter linear
	magfilter linear
}

fragoutput out_shadowmap {
	// depth attachment
	depth img_shadowmap
}

texture tex_shadowmap {
	img img_shadowmap
}

/////////////
// SHADERS //
/////////////

shader vert vs_shadowmap {
	#version 440
	
	layout(binding = 0) uniform SpotLight {
		mat4 viewProj;
	} light;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 in_pos;
	
	void main ()
	{
		// transform vertex to light projection space
		gl_Position = light.viewProj * in_pos;
	}
}

shader vert vs_render {
	#version 440
	
	layout(binding = 0) uniform SpotLight {
		mat4 viewProj;
		vec4 camera;
		vec4 light;
	} light;
	
	layout(binding = 1) uniform SimpleCamera {
		mat4 viewProj;
	} camera;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 in_pos;
	layout(location = 1) in vec4 in_col;

	// vertex shader output
	layout(location = 0) out vec4 out_lpos;
	layout(location = 1) out vec4 out_col;
	
	void main ()
	{
		// transform vertex to camera projection space
		gl_Position = camera.viewProj * in_pos;
		// transform vertex to light projection space
		out_lpos = light.viewProj * in_pos;
		// pass vertex color
		out_col = in_col;
	}
}

shader frag fs_render {
	#version 440
	#define NUM_POINTS 25
	#define PI 3.1415926535897932384626433832795
	
	layout(binding = 0) uniform SpotLight {
		mat4 viewProj;
		vec4 camera;
		vec4 light;
	} light;

	layout(binding = 2) uniform PoissonDisc {
		vec2 points[NUM_POINTS];
	} disc;
	
	layout(binding = 0) uniform sampler2D shadowmap;
	
	layout(location = 0) in vec4 in_lpos;
	layout(location = 1) in vec4 in_col;
	out vec4 color;

	float rand(vec2 xy) {
		return fract(sin(dot(xy ,vec2(12.9898,78.233))) * 43758.5453);
	}

	mat2 randRot(float angle) {
		float sa = sin(angle);
		float ca = cos(angle);
		return mat2(ca, -sa, ca, sa);
	}
	
	vec2 depthGradient(vec2 uv, float z)
	{
		vec2 dz_duv = vec2(0.0, 0.0);

		vec3 duvdist_dx = dFdx(vec3(uv,z));
		vec3 duvdist_dy = dFdy(vec3(uv,z));

		dz_duv.x = duvdist_dy.y * duvdist_dx.z;
		dz_duv.x -= duvdist_dx.y * duvdist_dy.z;

		dz_duv.y = duvdist_dx.x * duvdist_dy.z;
		dz_duv.y -= duvdist_dy.x * duvdist_dx.z;

		float det = (duvdist_dx.x * duvdist_dy.y) - (duvdist_dx.y * duvdist_dy.x);
		dz_duv /= det;

		return dz_duv;
	}

	float light2shadowmap(float radius, float zNear, float zReceiver) {
		return radius * (zReceiver - zNear) / zReceiver;
	}

	float light2penumbra(float radius, float zBlocker, float zReceiver) {
		return radius * (zReceiver - zBlocker) / zBlocker;
	}

	float penumbra2shadowmap(float penumbra, float zNear, float zReceiver) {
		return penumbra * zNear / zReceiver;
	}
	
	float biasZ(float z, vec2 zChange, vec2 offset) {
		return z + dot(zChange.yx, offset);
	}
	
	float exp2linDepth(float z, float zNear, float zFar) {
		//float z_n = 2.0 * z - 1.0;
		//return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
		//return (2 * zNear * zFar) / (zFar + zNear - z * (zFar - zNear));
		return zFar * zNear / (zFar - z * (zFar - zNear));  
	}

	float BlockerSearch(float filterR, float zNear, float zFar, vec3 lpos, vec2 zChange) {
		int nBlocker = 0;
		float zBlocker = 0.0;
		mat2 R = randRot(2 * PI * rand(lpos.xy));

		for (int i = 0; i < NUM_POINTS; i++) {
			vec2 p = R * disc.points[i] * filterR;
			float z = texture(shadowmap, lpos.xy + p).x;
			if (biasZ(lpos.z, zChange, p) > z) {
				zBlocker += z;
				nBlocker++;
			}
		}

		return exp2linDepth(zBlocker / float(nBlocker), zNear, zFar);
	}

	float PCF(float filterR, vec3 lpos, vec2 zChange) {
		// PCF SHADOW MAPPING
		float shadow = 0.0;
		mat2 R = randRot(2 * PI * rand(lpos.xy));

		for (int i = 0; i < NUM_POINTS; i++) {
			vec2 p = R * disc.points[i] * filterR;
			shadow += biasZ(lpos.z, zChange, p) > texture(shadowmap, lpos.xy + p).x ? 1.0 : 0.0;
		}

		return shadow / float(NUM_POINTS);
	}

	float PCSS(float radius, float zNear, float zFar, vec3 lpos, vec2 zChange) {
		float receiverZ = exp2linDepth(lpos.z, zNear, zFar);
		
		// BLOCKER SEARCH
		float filterR = light2shadowmap(radius, zNear, receiverZ);
		float zBlocker = BlockerSearch(filterR, zNear, zFar, lpos, zChange);
		if (isnan(zBlocker))
			zBlocker = receiverZ;

		// PCF SHADOW MAPPING
		float penumbraR = light2penumbra(radius, zBlocker, receiverZ);
		filterR = penumbra2shadowmap(penumbraR, zNear, receiverZ);
		return PCF(filterR, lpos, zChange);
	}
	
	void main ()
	{
		// pass color
		color = in_col;
		
		// if pixel outside light frustum clip space, do nothing
		if (any(greaterThan(abs(in_lpos), in_lpos.wwww)))
			return;
			
		// SHADOW MAPPING
		
		// transform to normalized device coordinates [-1;+1]
		// and then to shadow map texture coordinates [0;1]
		vec3 lpos = (in_lpos.xyz / in_lpos.w) * 0.5 + 0.5;
		vec2 zChange = depthGradient(lpos.xy, lpos.z);
		
		const vec2 r = 10.0 / textureSize(shadowmap, 0);
		float shadow = PCF((r.x + r.y) * 0.5, lpos, zChange);
		//float shadow = PCSS(light.light.y, light.camera.z,
		//	light.camera.w, lpos, zChange);
		if (shadow == 0.0)
			return;
		
		color.rgb *= (1.0 - shadow) * 0.5 + 0.5;
	}
}

/////////////
// PROGRAM //
/////////////

csharp cs_util {
	file "<csharp>/StaticCamera.cs" ...
		 "<csharp>/SimpleCamera.cs" ...
		 "<csharp>/SpotLight.cs" ...
	     "<csharp>/PoissonDisc.cs" ...
		 "<csharp>/UniformBlock.cs"
}

instance cs_light {
	class cs_util csharp.SpotLight
	name SpotLight
	pos 3 4 3
	rot -45 45 0
	near 2
	far 20
	radius 0.5
}

instance cs_camera {
	class cs_util csharp.SimpleCamera
	name SimpleCamera
	pos -5 4 10
	rot -20 -15 0
}

instance cs_poisson {
	class cs_util csharp.PoissonDisc
	name PoissonDisc
	maxSamples 64
	minRadius 0.3
}

pass pass_shadowmap {
	// attach shaders
	vert vs_shadowmap

	// render to
	fragout out_shadowmap
	
	// OpenGL calls
	Clear depthBit
	Enable depthTest
	Enable CullFace

	// execute camera code
	exec cs_light
	
	// draw cube
	draw buf_idx in_vert ushort triangles 0 0 36
	draw buf_idx in_vert ushort triangles 8 36 6
}

pass pass_render {
	// attach shaders
	vert vs_render
	frag fs_render
	
	tex tex_shadowmap 0
	
	// OpenGL calls
	ClearColor 0.1 0.3 1.0 0.0
	Clear colorDepthBit
	Enable depthTest

	// execute camera code
	exec cs_light
	exec cs_camera
	exec cs_poisson
	
	// draw cube
	draw buf_idx in_vert ushort triangles 0 0 36
	draw buf_idx in_vert ushort triangles 8 36 6
}

pass pass_reset {
	ClearColor 0 0 0 0
	Disable depthTest
	Disable CullFace
}

tech tech_simple {
	pass pass_shadowmap
	pass pass_render
	pass pass_reset
}