// AUTHOR: Michael Hecher

/////////////
// BUFFERS //
/////////////

buffer buff_pos {
	// buffer will only be used for reading
	// and will not be updated during runtime
	usage staticDraw
	// load <pos></pos> data from XML file
	// these are vertex positions for each vertex
	file "geom/cube.xml|position" "geom/plane.xml|position"
}

buffer buff_color {
	usage staticDraw
	file "geom/cube.xml|color" "geom/plane.xml|color"
}

buffer buf_idx {
	usage staticDraw
	file "geom/cube.xml|index" "geom/plane.xml|index"
}

image img_shadowmap {
	// image size in pixels
	width 512
	height 512
	// pixel format is a 32
	// bit floating point depth
	format depth32f
}

/////////////////////
// BUFFER BINDINGS //
/////////////////////

vertinput in_vert {
	// first attribute: floating point
	// vertex positions (x,y,z,1)
	attr buff_pos float 4
	// second attribute: floating point
	// vertex colors (x,y,z,1)
	attr buff_color float 4
}

sampler samp_linear {
	minfilter linear
	magfilter linear
}

fragoutput out_shadowmap {
	// depth attachment
	depth img_shadowmap
}

texture tex_shadowmap {
	img img_shadowmap
}

/////////////
// SHADERS //
/////////////

shader vert vs_shadowmap {
	#version 440
	
	uniform mat4 g_lightproj;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 in_pos;
	
	void main ()
	{
		// transform vertex to light projection space
		gl_Position = g_lightproj * in_pos;
	}
}

shader vert vs_simple {
	#version 440
	
	uniform mat4 g_viewproj;
	uniform mat4 g_lightproj;
	
	// vertex input as specified by 'in_vert'
	layout(location = 0) in vec4 in_pos;
	layout(location = 1) in vec4 in_col;

	// vertex shader output
	layout(location = 0) out vec4 out_lpos;
	layout(location = 1) out vec4 out_col;
	
	void main ()
	{
		// transform vertex to camera projection space
		gl_Position = g_viewproj * in_pos;
		// transform vertex to light projection space
		out_lpos = g_lightproj * in_pos;
		// pass vertex color
		out_col = in_col;
	}
}

shader frag fs_simple {
	#version 440
	
	layout(binding = 0) uniform sampler2D shadowmap;
	
	layout(location = 0) in vec4 in_lpos;
	layout(location = 1) in vec4 in_col;
	out vec4 color;
	
	float dxdyBias(float bias, int dx, int dy) {
		return bias + abs(bias * dx) + abs(bias * dy);
	}
	
	void main ()
	{
		// pass color
		color = in_col;
		
		// if pixel outside light frustum clip space, do nothing
		if (any(greaterThan(abs(in_lpos), in_lpos.wwww)))
			return;
			
		// SHADOW MAPPING
		
		// transform to normalized device coordinates [-1;+1]
		// and then to shadow map texture coordinates [0;1]
		vec3 lpos = (in_lpos.xyz / in_lpos.w) * 0.5 + 0.5;
		
		const int r = 2;
		const int d = 2*r+1;
		const float bias = 0.001;
		float shadow = 0.0;
		for (int dx = -r; dx <= r; dx++) {
			for (int dy = -r; dy <= r; dy++)
				shadow += lpos.z - dxdyBias(bias, dx, dy) > textureOffset(shadowmap, lpos.xy, ivec2(dx, dy)).x ? 1.0 : 0.0;
		}
		
		if (shadow == 0.0)
			return;
		shadow /= float(d*d);
		color.rgb *= (1.0 - shadow) * 0.5 + 0.5;
	}
}

/////////////
// PROGRAM //
/////////////

csharp cs_util {
	file "util/StaticCamera.cs" "util/SimpleCamera.cs"
}

pass pass_shadowmap {
	// attach shaders
	vert vs_shadowmap

	// render to
	fragout out_shadowmap
	
	// OpenGL calls
	Clear depthBit
	Enable depthTest

	// execute camera code
	exec cs_util util.StaticCamera 60 0.1 100 3 4 3 -45 45 0 "g_light" "g_proj" "g_lightproj"
	
	// draw cube
	draw buf_idx in_vert ushort triangles 0 0 36
	draw buf_idx in_vert ushort triangles 8 36 6
}

pass pass_render {
	// attach shaders
	vert vs_simple
	frag fs_simple
	
	tex tex_shadowmap 0
	
	// OpenGL calls
	ClearColor 0.1 0.3 1.0 0.0
	Clear colorDepthBit
	Enable depthTest

	// execute camera code
	exec cs_util util.SimpleCamera 60 0.1 100 -5 4 10 -20 -15
	exec cs_util util.StaticCamera 60 0.1 100 3 4 3 -45 45 0 "g_light" "g_proj" "g_lightproj"
	
	// draw cube
	draw buf_idx in_vert ushort triangles 0 0 36
	draw buf_idx in_vert ushort triangles 8 36 6
}

pass pass_reset {
	ClearColor 0 0 0 0
	Disable depthTest
}

tech tech_simple {
	pass pass_shadowmap
	pass pass_render
	pass pass_reset
}