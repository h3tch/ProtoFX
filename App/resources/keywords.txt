┬.*
├1║buffer║buffer <name>¶
├1║csharp║assembly <path> [path] [...]¶
├1║fragoutput║fragoutput <name>¶
├1║image║image <name>¶
├1║instance║instance <name>¶
├1║pass║pass <name>¶
├1║sampler║sampler <name>¶
├1║shader║shader <shader_type> <name>¶
├1║tech║tech <name>¶
├1║text║text <name>¶
├1║texture║texture <name>¶
├1║vertinput║vertinput <name>¶
├1║vertoutput║vertoutput <name>¶
├┬(?<=buffer\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├3║size║size <bytes>¶
│├3║xml║xml <path> <node>¶
│├3║txt║txt <text_name>¶
│├3║usage║usage <usage_hint>¶
│├┬(?<=usage\s+)\w*\s*(?=\n)
│ ├4║dynamicCopy¶
│ ├4║dynamicDraw¶
│ ├4║dynamicRead¶
│ ├4║staticCopy¶
│ ├4║staticDraw¶
│ ├4║staticRead¶
│ ├4║streamCopy¶
│ ├4║streamDraw¶
│ ├4║streamRead¶
├┬(?<=csharp\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├3║assembly║assembly <path> [path] [...]¶
│├3║file║file <path> [path] [...]¶
├┬(?<=fragoutput\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├3║color║color <image_name>¶
│├3║depth║depth <image_name>¶
│├3║height║height <pixels>¶
│├3║width║width <pixels>¶
├┬(?<=image\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├3║format║format <pixel_format>¶
│├3║size║width <width> <height> <depth> <length>¶
│├3║file║file <path> [path] [...]¶
│├┬(?<=format\s+)\w*\s*(?=\n)
││├4║depth¶
││├4║depth16¶
││├4║depth24¶
││├4║depth24stencil8¶
││├4║depth32¶
││├4║depth32f¶
││├4║depth32fstencil8¶
││├4║depthstencil¶
││├4║r8¶
││├4║r8i¶
││├4║r8ui¶
││├4║r16¶
││├4║r16i¶
││├4║r16ui¶
││├4║r16f¶
││├4║r32i¶
││├4║r32ui¶
││├4║r32f¶
││├4║rg8¶
││├4║rg8i¶
││├4║rg8ui¶
││├4║rg16¶
││├4║rg16i¶
││├4║rg16ui¶
││├4║rg16f¶
││├4║rg32i¶
││├4║rg32ui¶
││├4║rg32f¶
││├4║rgb8¶
││├4║rgb8i¶
││├4║rgb8ui¶
││├4║rgb16¶
││├4║rgb16i¶
││├4║rgb16ui¶
││├4║rgb16f¶
││├4║rgb32i¶
││├4║rgb32ui¶
││├4║rgb32f¶
││├4║rgba8¶
││├4║rgba8i¶
││├4║rgba8ui¶
││├4║rgba16¶
││├4║rgba16i¶
││├4║rgba16ui¶
││├4║rgba16f¶
││├4║rgba32i¶
││├4║rgba32ui¶
││├4║rgba32f¶
│├┬(?<=type\s+)\w*\s*(?=\n)
│ ├4║texture1D║1D texture¶
│ ├4║texture2D║2D texture¶
│ ├4║texture3D║3D texture/volume texture¶
│ ├4║texture1DArray║1D texture array¶
│ ├4║texture2DArray║2D texture array¶
├┬(?<=instance\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├3║class║class <csharp_name> <c#_class>¶
│├3║name║name <new_name>¶
├┬(?<=pass\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├4║break¶
│├3║comp║comp <shader_name>¶
│├3║compute║Dispatch compute shader call.
││         ║> compute <num_group_x> <num_group_y> [num_group_z]
││         ║> compute <callbuffer_name>¶
│├3║draw║Draw vertex based (possibly indexed) geometry.
││      ║
││      ║> draw <vertinput_name> <primitive_type> <base_vertex> <vertex_count>
││      ║       [base_instance] [instance_count]
││      ║> draw <vertinput_name> <indexbuffer_name> <index_type> <primitive_type>
││      ║       <base_vertex> <base_index> <index_count> [base_instance] [instance_count]
││      ║> draw <vertinput_name> <callbuffer_name> <primitive_type>
││      ║       [buffer_offset] [draw_count] [stride]
││      ║> draw <vertinput_name> <indexbuffer_name> <index_type> <callbuffer_name>
││      ║       <primitive_type> [buffer_offset]  [draw_count] [stride]
││      ║> draw <vertoutput_name> <primitive_type> [vertoutput_stream] [instance_count]
││      ║
││      ║primitive_type
││      ║    points, lines, lineLoop, lineStrip, triangles, triangleStrip, triangleFan, patch,
││      ║    linesAdjacency, lineStripAdjacency, trianglesAdjacency, triangleStripAdjacency
││      ║index_type
││      ║    ubyte, ushort, uint¶
│├┬(?<=draw\s+)(\w\d\s)*(?=\n)
│|├4║lineLoop¶
│|├4║lines¶
│|├4║linesAdjacency¶
│|├4║lineStrip¶
│|├4║lineStripAdjacency¶
│|├4║patch¶
│|├4║points¶
│|├4║triangleFan¶
│|├4║triangles¶
│|├4║trianglesAdjacency¶
│|├4║triangleStrip¶
│|├4║triangleStripAdjacency¶
│|├4║ubyte║index buffer type is unsigned byte¶
│|├4║uint║index buffer type is unsigned integer¶
│|├4║ushort║index buffer type is unsigned short¶
│├3║fragout║fragout <fragoutput_name>¶
│├3║vertout║vertout <vertoutput_name> <output_primitive_type> [write_mode] <output_varying_name>
││	       ║
││         ║The optional argument [write_mode] can be 'gl_SeparateAttribs' (write every
││         ║<output_varying_name> to a new buffer) or the default 'gl_InterleavedAttribs'
││         ║(output varyings for different buffers need to be separated by 'gl_NextBuffer')¶
│├┬(?<=vertout\s+)\w*\s*(?=\n)
│|├4║lines¶
│|├4║points¶
│|├4║triangles¶
│├3║eval║eval <shader_name>¶
│├3║exec║exec <instance_name>¶
│├3║frag║frag <shader_name>¶
│├3║geom║geom <shader_name>¶
│├3║tess║tess <shader_name>¶
│├3║tex║Bind or unbind a texture from a texture unit.
││     ║tex <texture_name> <unit> -- bind to unit
││     ║tex <unit>                -- unbind unit¶
│├3║img║Bind or unbind a texture from an image unit.
││     ║img <texture_name> <unit> <level> <layer> <access> <format> -- bind to unit
││     ║img <unit>                                                  -- unbind unit¶
│├3║vert║vert <shader_name>¶
│├10║glBeginConditionalRender¶
│├10║glBeginQuery¶
│├10║glBeginQueryIndexed¶
│├10║glBlendColor¶
│├10║glBlendEquation¶
│├10║glBlendEquationi¶
│├10║glBlendEquationSeparate¶
│├10║glBlendEquationSeparatei¶
│├10║glBlendFunc¶
│├10║glBlendFunci¶
│├10║glBlendFuncSeparate¶
│├10║glBlendFuncSeparatei¶
│├10║glClampColor¶
│├10║glClear¶
│├10║glClearBuffer¶
│├10║glClearBufferData¶
│├10║glClearBufferfi¶
│├10║glClearBufferfv¶
│├10║glClearBufferiv¶
│├10║glClearBufferSubData¶
│├10║glClearBufferuiv¶
│├10║glClearColor¶
│├10║glClearDepth¶
│├10║glClearDepthf¶
│├10║glClearNamedBufferData¶
│├10║glClearNamedBufferSubData¶
│├10║glClearNamedFramebufferfi¶
│├10║glClearNamedFramebufferfv¶
│├10║glClearNamedFramebufferiv¶
│├10║glClearNamedFramebufferuiv¶
│├10║glClearStencil¶
│├10║glClearTexImage¶
│├10║glClearTexSubImage¶
│├10║glClientWaitSync¶
│├10║glClipControl¶
│├10║glColorMask¶
│├10║glColorMaski¶
│├10║glCullFace¶
│├10║glDepthFunc¶
│├10║glDepthMask¶
│├10║glDepthRange¶
│├10║glDepthRangeArray¶
│├10║glDepthRangeArrayv¶
│├10║glDepthRangef¶
│├10║glDepthRangeIndexed¶
│├10║glDetachShader¶
│├10║glDisable¶
│├10║glDisablei¶
│├10║glEnable¶
│├10║glEnablei¶
│├10║glEndConditionalRender¶
│├10║glEndQuery¶
│├10║glEndQueryIndexed¶
│├10║glEndTransformFeedback¶
│├10║glFlush¶
│├10║glFrontFace¶
│├10║glLineWidth¶
│├10║glLogicOp¶
│├10║glMemoryBarrier¶
│├10║glMemoryBarrierByRegion¶
│├10║glMinSampleShading¶
│├10║glPatchParameter¶
│├10║glPatchParameterfv¶
│├10║glPatchParameteri¶
│├10║glPauseTransformFeedback¶
│├10║glPointParameter¶
│├10║glPointParameterf¶
│├10║glPointParameterfv¶
│├10║glPointParameteri¶
│├10║glPointParameteriv¶
│├10║glPointSize¶
│├10║glPolygonMode¶
│├10║glPolygonOffset¶
│├10║glPopDebugGroup¶
│├10║glPrimitiveRestartIndex¶
│├10║glProvokingVertex¶
│├10║glPushDebugGroup¶
│├10║glQueryCounter¶
│├10║glResumeTransformFeedback¶
│├10║glSampleCoverage¶
│├10║glSampleMaski¶
│├10║glSamplerParameter¶
│├10║glSamplerParameterf¶
│├10║glSamplerParameterfv¶
│├10║glSamplerParameteri¶
│├10║glSamplerParameterIiv¶
│├10║glSamplerParameterIuiv¶
│├10║glSamplerParameteriv¶
│├10║glScissor¶
│├10║glScissorArray¶
│├10║glScissorArrayv¶
│├10║glScissorIndexed¶
│├10║glScissorIndexedv¶
│├10║glShaderStorageBlockBinding¶
│├10║glStencilFunc¶
│├10║glStencilFuncSeparate¶
│├10║glStencilMask¶
│├10║glStencilMaskSeparate¶
│├10║glStencilOp¶
│├10║glStencilOpSeparate¶
│├10║glTextureBarrier¶
│├10║glUniform1f¶
│├10║glUniform1fv¶
│├10║glUniform1i¶
│├10║glUniform1iv¶
│├10║glUniform1ui¶
│├10║glUniform1uiv¶
│├10║glUniform2f¶
│├10║glUniform2fv¶
│├10║glUniform2i¶
│├10║glUniform2iv¶
│├10║glUniform2ui¶
│├10║glUniform2uiv¶
│├10║glUniform3f¶
│├10║glUniform3fv¶
│├10║glUniform3i¶
│├10║glUniform3iv¶
│├10║glUniform3ui¶
│├10║glUniform3uiv¶
│├10║glUniform4f¶
│├10║glUniform4fv¶
│├10║glUniform4i¶
│├10║glUniform4iv¶
│├10║glUniform4ui¶
│├10║glUniform4uiv¶
│├10║glUniformBlockBinding¶
│├10║glUniformMatrix2fv¶
│├10║glUniformMatrix2x3fv¶
│├10║glUniformMatrix2x4fv¶
│├10║glUniformMatrix3fv¶
│├10║glUniformMatrix3x2fv¶
│├10║glUniformMatrix3x4fv¶
│├10║glUniformMatrix4fv¶
│├10║glUniformMatrix4x2fv¶
│├10║glUniformMatrix4x3fv¶
│├10║glUniformSubroutines¶
│├10║glUniformSubroutinesuiv¶
│├10║glViewport¶
│├10║glViewportArray¶
│├10║glViewportArrayv¶
│├10║glViewportIndexed¶
│├10║glViewportIndexedf¶
│├10║glViewportIndexedfv¶
│├10║glWaitSync¶
├┬(?<=sampler\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├3║magfilter║magfilter <filter_type>¶
│├3║minfilter║minfilter <filter_type>¶
│├3║wrap║wrap <wrap_type>¶
│├┬(?<=magfilter\s+)\w*\s*(?=\n)
││├4║linear¶
││├4║nearest¶
│├┬(?<=minfilter\s+)\w*\s*(?=\n)
││├4║linear¶
││├4║nearest¶
││├4║linearMipmapLinear¶
││├4║linearMipmapNearest¶
││├4║nearestMipmapLinear¶
││├4║nearestMipmapNearest¶
│├┬(?<=wrap\s+)\w*\s*(?=\n)
│ ├4║clampToBorder¶
│ ├4║clampToEdge¶
│ ├4║mirroredRepeat¶
│ ├4║repeat¶
├┬(?<=tech\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├3║pass║Execute this pass every frame.
││      ║  pass <name>¶
│├3║init║Execute this pass only once
││      ║before all 'normal' passes.
││      ║  init <name>¶
│├3║uninit║Execute this pass only once
│         ║before the technique is destroyed.
│         ║  uninit <name>¶
├┬(?<=texture\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├3║buff║buff <name>¶
│├3║img║img <name>¶
│├3║samp║samp <name>¶
├┬(?<=vertinput\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├3║attr║attr <buff_name> <type> <dim> [stride] [offset] [divisor]¶
│├┬(?<=attr\s+)(\w\d\s)*(?=\n)
│ ├4║byte¶
│ ├4║double¶
│ ├4║float¶
│ ├4║int¶
│ ├4║short¶
│ ├4║ubyte¶
│ ├4║uint¶
│ ├4║unsignedByte¶
│ ├4║unsignedInt¶
│ ├4║unsignedShort¶
│ ├4║ushort¶
├┬(?<=vertoutput\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
│├3║buff║buff <name>¶
│├3║pause║pause <true_false>¶
│├3║resume║resume <true_false>¶
├┬(?:shader(\s+\w+){0,2}\s*)\{(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))\}
 ├┬(?<=shader)(\s+\w+){0,2}\s*(?=\{)
 │├2║comp║Compute shader annotation.
 ││      ║  in  uvec3 gl_NumWorkGroups
 ││      ║  in  uvec3 gl_WorkGroupSize
 ││      ║  in  uvec3 gl_WorkGroupID
 ││      ║  in  uvec3 gl_LocalInvocationID
 ││      ║  in  uvec3 gl_GlobalInvocationID
 ││      ║  in  uint  gl_LocalInvocationIndex¶
 │├2║vert║Vertex shader annotation.
 ││      ║  in  int   gl_VertexID
 ││      ║  in  int   gl_InstanceID
 ││      ║  out vec4  gl_Position
 ││      ║  out float gl_PointSize
 ││      ║  out float gl_ClipDistance[]¶
 │├2║tess║Tesselation control annotation.
 ││      ║  in  int   gl_PatchVerticesIn
 ││      ║  in  int   gl_PrimitiveID
 ││      ║  in  int   gl_InvocationID
 ││      ║  in  vec4  gl_in[].gl_Position
 ││      ║  in  float gl_in[].gl_PointSize
 ││      ║  in  float gl_in[].gl_ClipDistance[]
 ││      ║  out float gl_TessLevelOuter[3]
 ││      ║  out float gl_TessLevelInner[3]
 ││      ║  out vec4  gl_out[].gl_Position
 ││      ║  out float gl_out[].gl_PointSize
 ││      ║  out float gl_out[].gl_ClipDistance[]¶
 │├2║eval║Tesselation evaluation shader annotation.
 ││      ║  in  vec3  gl_TessCoord
 ││      ║  in  int   gl_PatchVerticesIn
 ││      ║  in  int   gl_PrimitiveID
 ││      ║  in  float gl_TessLevelOuter[3]
 ││      ║  in  float gl_TessLevelInner[1]
 ││      ║  in  vec4  gl_in[].gl_Position
 ││      ║  in  float gl_in[].gl_PointSize
 ││      ║  in  float gl_in[].gl_ClipDistance[]
 ││      ║  out vec4  gl_Position
 ││      ║  out float gl_PointSize
 ││      ║  out float gl_ClipDistance[]¶
 │├2║geom║Geometry shader annotation.
 ││      ║   in  int   gl_PrimitiveIDIn
 ││      ║   in  int   gl_InvocationID
 ││      ║   in  vec4  gl_in[].gl_Position
 ││      ║   in  float gl_in[].gl_PointSize
 ││      ║   in  float gl_in[].gl_ClipDistance[]
 ││      ║   out int   gl_PrimitiveID
 ││      ║   out int   gl_Layer
 ││      ║   out int   gl_ViewportIndex
 ││      ║   out vec4  gl_Position
 ││      ║   out float gl_PointSize
 ││      ║   out float gl_ClipDistance[]¶
 │├2║frag║Fragment shader annotation.
 │       ║  in  vec4  gl_FragCoord
 │       ║  in  bool  gl_FrontFacing
 │       ║  in  vec2  gl_PointCoord
 │       ║  in  int   gl_SampleID
 │       ║  in  vec2  gl_SamplePosition
 │       ║  in  int   gl_SampleMaskIn[]
 │       ║  in  float gl_ClipDistance[]
 │       ║  in  int   gl_PrimitiveID
 │       ║  in  int   gl_Layer
 │       ║  in  int   gl_ViewportIndex
 │       ║  out float gl_FragDepth
 │       ║  out int   gl_SampleMask[]¶
 ├┬(?<=shader\s+comp\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
 │├┬(?<=layout\s*\()(?:[^()]|(?<open>\()|(?<-open>\)))+(?(open)(?!))(?=\)\s+in)
 │ ├7║local_size_x¶
 │ ├7║local_size_y¶
 │ ├7║local_size_z¶
 ├┬(?<=shader\s+vert\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
 │├9║gl_InstanceID║contains the index of the current primitive in an instanced draw command¶
 │├9║gl_VertexID║contains the index of the current vertex¶
 ├┬(?<=shader\s+tess\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
 │├9║gl_InvocationID║contains the index of the output patch
 ││                 ║vertex assigned to the shader invocation¶
 │├9║gl_MaxPatchVertices║the maximum number of patch vertices supported¶
 │├9║gl_PatchVerticesIn║contains the number of vertices in the current patch¶
 │├9║gl_PrimitiveID║holds the number of primitives processed by the
 ││                ║shader since the current set of rendering
 ││                ║primitives was started¶
 │├9║gl_TessLevelInner║is used to assign values to the corresponding inner tesellation
 ││                   ║levels of the current patch. The values written into
 ││                   ║gl_TessLevelInner by the tessellation control shader are used
 ││                   ║by the tessellation primitive generator to control primitive
 ││                   ║tessellation and may be read by the subsequent tessellation
 ││                   ║evaluation shader.¶
 │├9║gl_TessLevelOuter║is used to assign values to the corresponding outer tesellation
 ││                   ║levels of the current patch. The values written into
 ││                   ║gl_TessLevelOuter by the tessellation control shader are used
 ││                   ║by the tessellation primitive generator to control primitive
 ││                   ║tessellation and may be read by the subsequent tessellation
 ││                   ║evaluation shader.¶
 │├9║gl_in║vertex input varying structure of the patch¶
 │├9║gl_out║vertex output varying structure of the patch¶
 │├┬(?<=layout\s*\()(?:[^()]|(?<open>\()|(?<-open>\)))+(?(open)(?!))(?=\)\s+out)
 │ ├7║vertices║Specify a particular vertex count for Tessellation Control Shaders output patches.¶
 ├┬(?<=shader\s+eval\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
 │├9║gl_MaxPatchVertices║the maximum number of patch vertices supported¶
 │├9║gl_PatchVerticesIn║contains the number of vertices in the current patch¶
 │├9║gl_PrimitiveID║is an output variable that is passed to the
 ││                ║corresponding gl_PrimitiveID input variable
 ││                ║in the fragment shader¶
 │├9║gl_TessLevelInner║contains the values written by the tessellation control shader,
 ││                   ║if present. If no tessellation control shader is present, it
 ││                   ║contains the default tessellation level.¶
 │├9║gl_TessLevelOuter║contains the values written by the tessellation control shader,
 ││                   ║if present. If no tessellation control shader is present, it
 ││                   ║contains the default tessellation level.¶
 │├9║gl_in║vertex input varying structure of the patch¶
 ├┬(?<=shader\s+geom\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
 │├9║gl_InvocationID║identifies the invocation number assigned
 ││                 ║to the geometry shader invocation¶
 │├9║gl_Layer║contains the selected layer of a multi-layer framebuffer attachment¶
 │├9║gl_PrimitiveID║is an output variable that is passed to the
 ││                ║corresponding gl_PrimitiveID input variable
 ││                ║in the fragment shader¶
 │├9║gl_PrimitiveIDIn║holds the number of primitives processed by the shader since
 ││                  ║the current set of rendering primitives was started¶
 │├9║gl_ViewportIndex║contains the index of the viewport to be used
 ││                  ║in viewport transformation and scissoring¶
 │├9║gl_in║vertex input varying structure of the primitive¶
 │├6║EmitStreamVertex║emit a vertex to a specified stream
 ││                  ║  void EmitStreamVertex(int stream)¶
 │├6║EmitVertex║emit a vertex to the first vertex stream
 ││            ║  void EmitVertex(void)¶
 │├6║EndPrimitive║complete the current output primitive
 ││              ║on the first vertex stream
 ││              ║  void EndPrimitive(void)¶
 │├6║EndStreamPrimitive║complete the current output primitive on a specified stream
 ││                    ║  void EndStreamPrimitive(int stream)¶
 │├┬(?<=layout\s*\()(?:[^()]|(?<open>\()|(?<-open>\)))+(?(open)(?!))(?=\)\s+in)
 ││├7║points║The input primitive type of the geometry shader are points.¶
 ││├7║lines║The input primitive type of the geometry shader are lines.¶
 ││├7║triangles║The input primitive type of the geometry shader are triangles.¶
 │├┬(?<=layout\s*\()(?:[^()]|(?<open>\()|(?<-open>\)))+(?(open)(?!))(?=\)\s+out)
 │ ├7║points║The output primitive type of the geometry shader are points.¶
 │ ├7║lines║The output primitive type of the geometry shader are lines.¶
 │ ├7║lines_adjacency║The output primitive type of the geometry shader are adjacency lines.¶
 │ ├7║triangles_adjacency║The output primitive type of the geometry shader are adjacency triangles.¶
 │ ├7║line_strip║The output primitive type of the geometry shader are line strips.¶
 │ ├7║triangle_strip║The output primitive type of the geometry shader are triangles strips.¶
 │ ├7║max_vertices║The number must be a compile-time constant, and it
 │                ║defines the maximum number of vertices that will
 │                ║be written by a single invocation of the GS.¶
 ├┬(?<=shader\s+frag\s+\w+\s*\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
 │├7║centroid¶
 │├8║discard¶
 │├6║fwidth║return the sum of the absolute
 ││        ║value of derivatives in x and y
 ││        ║  genType fwidth(genType p)¶
 │├6║fwidthCoarse║return the sum of the absolute
 ││              ║value of derivatives in x and y
 ││              ║  genType fwidthCoarse(genType p)¶
 │├6║fwidthFine║return the sum of the absolute
 ││            ║value of derivatives in x and y
 ││            ║  genType fwidthFine(genType p)¶
 │├9║gl_FragCoord║contains the window-relative coordinates
 ││              ║of the current fragment¶
 │├9║gl_FragDepth║establishes a depth value for the current fragment¶
 │├9║gl_FrontFacing║indicates whether a primitive is front or back facing¶
 │├9║gl_HelperInvocation║indicates whether a fragment shader invocation is a helper invocation¶
 │├9║gl_NumSamples║is the number of samples in the current Framebuffer¶
 │├9║gl_PointCoord║contains the coordinate of a fragment within a point¶
 │├9║gl_PointSize║contains size of rasterized points, in pixels¶
 │├9║gl_PrimitiveID║If no geomery shader is present then gl_PrimitiveID in the
 ││                ║fragment language behaves identically as it would in the
 ││                ║tessellation control and evaluation languages. If a geometry
 ││                ║shader is present but does not write to gl_PrimitiveID, the
 ││                ║value of gl_PrimitiveID in the fragment shader is undefined.¶
 │├9║gl_SampleID║contains the index of the sample currently being processed¶
 │├9║gl_SampleMask║specifies the sample coverage mask for the current fragment¶
 │├9║gl_SampleMaskIn║contains the computed sample coverage mask for the current fragment¶
 │├9║gl_SamplePosition║contains the location of the current sample within the current fragment¶
 │├9║gl_ViewportIndex║contains the index of the viewport the
 ││                  ║fragment was assigned to¶
 │├┬(?<=layout\s*\()(?:[^()]|(?<open>\()|(?<-open>\)))+(?(open)(?!))(?=\)\s+out)
 ││├7║depth_any║Disables the depth test.¶
 ││├7║depth_greater║To pass the depth test the new depth value must be greater.¶
 ││├7║depth_less║To pass the depth test the new depth value must be less.¶
 ││├7║depth_unchanged║To pass the depth test the new depth value must be equal.¶
 ││├7║early_fragment_tests║Perform depth test before executing the shader.¶
 ││├7║origin_upper_left║Specifies that gl_FragCoord​ will have the origin
 │││                   ║(0, 0) in the upper-left of the screen.¶
 ││├7║pixel_center_integer║Specifies that the X and Y of gl_FragCoord​ will
 ││                       ║be shifted by a half-pixel, so that the center
 ││                       ║of each pixel is an integer value.
 ││                       ║fragment was assigned to¶
 │├┬(?<=layout\s*\()(?:[^()]|(?<open>\()|(?<-open>\)))+(?(open)(?!))(?=\)\s+out)
 │ ├7║index║Used in combination with the location qualifier for dual source blending.¶
 ├┬(?<=\{)(?:[^{}]|(?<open>\{)|(?<-open>\}))+(?(open)(?!))(?=\})
  ├7║in¶
  ├7║out¶
  ├7║layout¶
  ├8║return¶
  ├8║break¶
  ├8║continue¶
  ├8║if¶
  ├8║else¶
  ├8║while¶
  ├8║for¶
  ├8║do¶
  ├8║switch¶
  ├8║case¶
  ├5║void¶
  ├5║bool¶
  ├5║int¶
  ├5║uint¶
  ├5║float¶
  ├5║atomic_uint¶
  ├5║bvec2¶
  ├5║bvec3¶
  ├5║bvec4¶
  ├5║ivec2¶
  ├5║ivec3¶
  ├5║ivec4¶
  ├5║uvec2¶
  ├5║uvec3¶
  ├5║uvec4¶
  ├5║vec2¶
  ├5║vec3¶
  ├5║vec4¶
  ├5║dvec2¶
  ├5║dvec3¶
  ├5║dvec4¶
  ├5║mat2¶
  ├5║mat2x2¶
  ├5║mat2x3¶
  ├5║mat2x4¶
  ├5║mat3¶
  ├5║mat3x2¶
  ├5║mat3x3¶
  ├5║mat3x4¶
  ├5║mat4¶
  ├5║mat4x2¶
  ├5║mat4x3¶
  ├5║mat4x4¶
  ├5║dmat2¶
  ├5║dmat2x2¶
  ├5║dmat2x3¶
  ├5║dmat2x4¶
  ├5║dmat3¶
  ├5║dmat3x2¶
  ├5║dmat3x3¶
  ├5║dmat3x4¶
  ├5║dmat4¶
  ├5║dmat4x2¶
  ├5║dmat4x3¶
  ├5║dmat4x4¶
  ├5║image1D║1D image binding unit¶
  ├5║image1DArray║1D image array binding unit¶
  ├5║image2D║2D image binding unit¶
  ├5║image2DArray║2D image array binding unit¶
  ├5║image2DMS║2D multi-sample image binding unit¶
  ├5║image2DMSArray║2D multi-sample image array binding unit¶
  ├5║image2DRect║2D rectangular image array binding unit¶
  ├5║image3D║3D image array binding unit¶
  ├5║imageBuffer║buffer image binding unit¶
  ├5║imageCube║cube map image binding unit¶
  ├5║imageCubeArray║cube map image array binding unit¶
  ├5║isampler1D║1D texture binding unit for integer textures¶
  ├5║isampler1DArray║1D texture array binding unit for integer textures¶
  ├5║isampler2D║2D texture binding unit for integer textures¶
  ├5║isampler2DArray║2D texture array binding unit for integer textures¶
  ├5║isampler2DMS║2D multi sample texture binding unit for integer textures¶
  ├5║isampler2DMSArray║2D multi sample texture array binding unit for integer textures¶
  ├5║isampler2DRect║2D rectangular texture binding unit for integer textures¶
  ├5║isampler3D║3D texture binding unit for integer textures¶
  ├5║isamplerBuffer║buffer texture binding unit for integer textures¶
  ├5║isamplerCube║cube map texture binding unit for integer textures¶
  ├5║isamplerCubeArray║cube map texture array binding unit for integer textures¶
  ├5║sampler1D║1D texture binding unit¶
  ├5║sampler1DArray║1D texture array binding unit¶
  ├5║sampler1DArrayShadow║1D shadow texture array binding unit¶
  ├5║sampler1DShadow║1D shadow texture binding unit¶
  ├5║sampler2D║2D texture binding unit¶
  ├5║sampler2DArray║2D texture array binding unit¶
  ├5║sampler2DArrayShadow║2D shadow texture array binding unit¶
  ├5║sampler2DMS║2D multi-sample texture binding unit¶
  ├5║sampler2DMSArray║2D multi-sample texture array binding unit¶
  ├5║sampler2DRect║2D rectangular texture array binding unit¶
  ├5║sampler2DRectShadow║2D rectangular shadow texture array binding unit¶
  ├5║sampler2DShadow║2D shadow texture binding unit¶
  ├5║sampler3D║3D texture array binding unit¶
  ├5║samplerBuffer║buffer texture binding unit¶
  ├5║samplerCube║cube map binding unit¶
  ├5║samplerCubeArray║cube map array binding unit¶
  ├5║samplerCubeArrayShadow║shadow cube map array binding unit¶
  ├5║samplerCubeShadow║shadow cube map binding unit¶
  ├6║abs║return the absolute value of the parameter
  │     ║  genType  abs(genType  x)
  │     ║  genIType abs(genIType x)
  │     ║  genDType abs(genDType x)¶
  ├6║acos║return the arccosine of the parameter
  │      ║  genType acos(genType x)¶
  ├6║acosh║return the arc hyperbolic cosine of the parameter
  │       ║  genType acosh(genType x)¶
  ├6║all║check whether all elements of a boolean vector are true
  │     ║  bool all(bvec x)¶
  ├6║any║check whether any element of a boolean vector is true
  │     ║  bool any(bvec x)¶
  ├6║asin║return the arcsine of the parameter
  │      ║  genType asin(genType x)¶
  ├6║asinh║return the arc hyperbolic sine of the parameter
  │       ║  genType asinh(genType x)¶
  ├6║atan║return the arc-tangent of the parameters
  │      ║  genType atan(genType x)¶
  ├6║atanh║return the arc hyperbolic tangent of the parameter
  │       ║  genType atanh(genType x)¶
  ├6║atomicAdd║perform an atomic addition to a variable
  │           ║  int  atomicAdd(inout int  mem, int  data)
  │           ║  uint atomicAdd(inout uint mem, uint data)¶
  ├6║atomicAnd║perform an atomic logical AND operation to a variable
  │           ║  int  atomicAdd(inout int  mem, int  data)
  │           ║  uint atomicAdd(inout uint mem, uint data)¶
  ├6║atomicCompSwap║perform an atomic compare-exchange operation to a variable
  │                ║  int  atomicCompSwap(inout int  mem, uint compare, uint data)
  │                ║  uint atomicCompSwap(inout uint mem, uint compare, uint data)¶
  ├6║atomicCounter║return the current value of an atomic counter
  │               ║  uint atomicCounter(atomic_uint c)¶
  ├6║atomicCounterDecrement║atomically decrement a counter and return the prior value
  │                        ║  uint atomicCounterDecrement(atomic_uint c)¶
  ├6║atomicCounterIncrement║atomically increment a counter and return the prior value
  │                        ║  uint atomicCounterIncrement(atomic_uint c)¶
  ├6║atomicExchange║perform an atomic exchange operation to a variable
  │                ║  int  atomicExchange(inout int  mem, int  data)
  │                ║  uint atomicExchange(inout uint mem, uint data)¶
  ├6║atomicMax║perform an atomic max operation to a variable
  │           ║  int  atomicMax(inout int  mem, int  data)
  │           ║  uint atomicMax(inout uint mem, uint data)¶
  ├6║atomicMin║perform an atomic min operation to a variable
  │           ║  int  atomicMin(inout int  mem, int  data)
  │           ║  uint atomicMin(inout uint mem, uint data)¶
  ├6║atomicOr║perform an atomic logical OR operation to a variable
  │          ║  int  atomicOr(inout int  mem, int  data)
  │          ║  uint atomicOr(inout uint mem, uint data)¶
  ├6║atomicXor║perform an atomic logical exclusive OR operation to a variable
  │           ║  int  atomicXor(inout int  mem, int  data)
  │           ║  uint atomicXor(inout uint mem, uint data)¶
  ├6║barrier║synchronize execution of multiple shader invocations
  │         ║  void barrier(void)¶
  ├6║bitCount║counts the number of 1 bits in an integer
  │          ║  genIType bitCount(genIType value)
  │          ║  genIType bitCount(genUType value)¶
  ├6║bitfieldExtract║extract a range of bits from an integer
  │                 ║  genIType bitfieldExtract(genIType value, int offset, int bits)
  │                 ║  genUType bitfieldExtract(genUType value, int offset, int bits)¶
  ├6║bitfieldInsert║insert a range of bits into an integer
  │                ║  genIType bitfieldInsert(genIType base, genIType insert, int offset, int bits)
  │                ║  genUType bitfieldInsert(genUType base, genUType insert, int offset, int bits)¶
  ├6║bitfieldReverse║reverse the order of bits in an integer
  │                 ║  genIType bitfieldReverse(genIType value)
  │                 ║  genUType bitfieldReverse(genUType value)¶
  ├6║ceil║find the nearest integer that is greater
  │      ║than or equal to the parameter
  │      ║  genType  ceil(genType  x)
  │      ║  genDType ceil(genDType x)¶
  ├6║clamp║constrain a value to lie between two further values
  │       ║  genType  clamp(genType  x, genType minVal, genType maxVal)
  │       ║  genType  clamp(genType  x, float minVal, float maxVal)
  │       ║  genDType clamp(genDType x, genDType minVal, genDType maxVal)
  │       ║  genDType clamp(genDType x, double minVal, double maxVal)
  │       ║  genIType clamp(genIType x, genIType minVal, genIType maxVal)
  │       ║  genIType clamp(genIType x, int minVal, int maxVal)
  │       ║  genUType clamp(genUType x, genUType minVal, genUType maxVal)
  │       ║  genUType clamp(genUType x, uint minVal, uint maxVal)¶
  ├6║cos║return the cosine of the parameter
  │     ║  genType cos(genType angle)¶
  ├6║cosh║return the hyperbolic cosine of the parameter
  │      ║  genType cosh(genType x)¶
  ├6║cross║calculate the cross product of two vectors
  │       ║  vec3  cross(vec3  x, vec3  y)
  │       ║  dvec3 cross(dvec3 x, dvec3 y)¶
  ├6║degrees║convert a quantity in radians to degrees
  │         ║  genType degrees(genType radians)¶
  ├6║determinant║calculate the determinant of a matrix
  │             ║  float determinant(mat2 m)
  │             ║  float determinant(mat3 m)
  │             ║  float determinant(mat4 m)
  │             ║  double determinant(dmat2 m)
  │             ║  double determinant(dmat3 m)
  │             ║  double determinant(dmat4 m)¶
  ├6║distance║calculate the distance between two points
  │          ║  float distance(genType p0, genType p1)
  │          ║  double distance(genDType p0, genDType p1)¶
  ├6║dot║calculate the dot product of two vectors
  │     ║  float dot(genType x, genType y)
  │     ║  double dot(genDType x, genDType y)¶
  ├6║equal║perform a component-wise equal-to
  │       ║comparison of two vectors
  │       ║  bvec equal(vec x, vec y)
  │       ║  bvec equal(ivec x, ivec y)
  │       ║  bvec equal(uvec x, uvec y)¶
  ├6║exp║return the natural exponentiation of the parameter
  │     ║  genType exp(genType x)¶
  ├6║exp2║return 2 raised to the power of the parameter
  │      ║  genType exp2(genType x)¶
  ├6║faceforward║return a vector pointing in the same direction as another
  │             ║  genType  faceforward(genType  N, genType  I, genType  Nref)
  │             ║  genDType faceforward(genDType N, genDType I, genDType Nref)¶
  ├6║findLSB║find the index of the least significant
  │         ║bit set to 1 in an integer
  │         ║  genIType findLSB(genIType value)
  │         ║  genIType findLSB(genUType value)¶
  ├6║findMSB║find the index of the most significant
  │         ║bit set to 1 in an integer
  │         ║  genIType findMSB(genIType value)
  │         ║  genIType findMSB(genUType value)¶
  ├6║floor║find the nearest integer less than
  │       ║or equal to the parameter
  │       ║  genType  floor(genType  x)
  │       ║  genDType floor(genDType x)¶
  ├6║fma║perform a fused multiply-add operation (a * b + c)
  │     ║  genType  fma(genType  a, genType  b, genType  c)
  │     ║  genDType fma(genDType a, genDType b, genDType c)¶
  ├6║fract║compute the fractional part of the argument
  │       ║  genType  fract(genType  x)
  │       ║  genDType fract(genDType x)¶
  ├6║frexp║split a floating point number
  │       ║  genType  frexp(genType  x, out genIType exp)
  │       ║  genDType frexp(genDType x, out genIType exp)¶
  ├6║greaterThan║perform a component-wise greater-than
  │             ║comparison of two vectors
  │             ║  bvec greaterThan(vec x, vec y)
  │             ║  bvec greaterThan(ivec x, ivec y)
  │             ║  bvec greaterThan(uvec x, uvec y)¶
  ├6║greaterThanEqual║perform a component-wise greater-than-or-equal
  │                  ║comparison of two vectors
  │                  ║  bvec greaterThanEqual(vec x, vec y)
  │                  ║  bvec greaterThanEqual(ivec x, ivec y)
  │                  ║  bvec greaterThanEqual(uvec x, uvec y)¶
  ├6║groupMemoryBarrier║controls the ordering of memory transaction issued
  │                    ║shader invocation relative to a work group
  │                    ║  void groupMemoryBarrier(void)¶
  ├6║imageAtomicAdd║atomically add a value to an existing value in memory
  │                ║and return the original value
  │                ║  uint imageAtomicAdd(gimage1D image, int   P, uint data)
  │                ║  uint imageAtomicAdd(gimage2D image, ivec2 P, uint data)
  │                ║  uint imageAtomicAdd(gimage3D image, ivec3 P, uint data)
  │                ║  uint imageAtomicAdd(gimage2DRect image, ivec2 P, uint data)
  │                ║  uint imageAtomicAdd(gimageCube   image, ivec3 P, uint data)
  │                ║  uint imageAtomicAdd(gbufferImage image, int   P, uint data)
  │                ║  uint imageAtomicAdd(gimage1DArray   image, ivec2 P, uint data)
  │                ║  uint imageAtomicAdd(gimage2DArray   image, ivec3 P, uint data)
  │                ║  uint imageAtomicAdd(gimageCubeArray image, ivec3 P, uint data)
  │                ║  uint imageAtomicAdd(gimage2DMS image, ivec2 P, int sample, uint data)
  │                ║  uint imageAtomicAdd(gimage2DMSArray image, ivec3 P, int sample, uint data)
  │                ║  int  imageAtomicAdd(gimage1D image, int   P, int data)
  │                ║  int  imageAtomicAdd(gimage2D image, ivec2 P, int data)
  │                ║  int  imageAtomicAdd(gimage3D image, ivec3 P, int data)
  │                ║  int  imageAtomicAdd(gimage2DRect image, ivec2 P, int data)
  │                ║  int  imageAtomicAdd(gimageCube   image, ivec3 P, int data)
  │                ║  int  imageAtomicAdd(gbufferImage image, int   P, int data)
  │                ║  int  imageAtomicAdd(gimage1DArray   image, ivec2 P, int data)
  │                ║  int  imageAtomicAdd(gimage2DArray   image, ivec3 P, int data)
  │                ║  int  imageAtomicAdd(gimageCubeArray image, ivec3 P, int data)
  │                ║  int  imageAtomicAdd(gimage2DMS image, ivec2 P, int sample, int data)
  │                ║  int  imageAtomicAdd(gimage2DMSArray image, ivec3 P, int sample, int data)¶
  ├6║imageAtomicAnd║atomically compute the logical AND of a value with an existing
  │                ║value in memory, store that value and return the original value
  │                ║  uint imageAtomicAnd(gimage1D image, int   P, uint data)
  │                ║  uint imageAtomicAnd(gimage2D image, ivec2 P, uint data)
  │                ║  uint imageAtomicAnd(gimage3D image, ivec3 P, uint data)
  │                ║  uint imageAtomicAnd(gimage2DRect image, ivec2 P, uint data)
  │                ║  uint imageAtomicAnd(gimageCube   image, ivec3 P, uint data)
  │                ║  uint imageAtomicAnd(gbufferImage image, int   P, uint data)
  │                ║  uint imageAtomicAnd(gimage1DArray   image, ivec2 P, uint data)
  │                ║  uint imageAtomicAnd(gimage2DArray   image, ivec3 P, uint data)
  │                ║  uint imageAtomicAnd(gimageCubeArray image, ivec3 P, uint data)
  │                ║  uint imageAtomicAnd(gimage2DMS image, ivec2 P, int sample, uint data)
  │                ║  uint imageAtomicAnd(gimage2DMSArray image, ivec3 P, int sample, uint data)
  │                ║  int  imageAtomicAnd(gimage1D image, int   P, int data)
  │                ║  int  imageAtomicAnd(gimage2D image, ivec2 P, int data)
  │                ║  int  imageAtomicAnd(gimage3D image, ivec3 P, int data)
  │                ║  int  imageAtomicAnd(gimage2DRect image, ivec2 P, int data)
  │                ║  int  imageAtomicAnd(gimageCube   image, ivec3 P, int data)
  │                ║  int  imageAtomicAnd(gbufferImage image, int   P, int data)
  │                ║  int  imageAtomicAnd(gimage1DArray   image, ivec2 P, int data)
  │                ║  int  imageAtomicAnd(gimage2DArray   image, ivec3 P, int data)
  │                ║  int  imageAtomicAnd(gimageCubeArray image, ivec3 P, int data)
  │                ║  int  imageAtomicAnd(gimage2DMS image, ivec2 P, int sample, int data)
  │                ║  int  imageAtomicAnd(gimage2DMSArray image, ivec3 P, int sample, int data)¶
  ├6║imageAtomicCompSwap║atomically compares supplied data with that in memory and
  │                     ║conditionally stores it to memory
  │                     ║  uint imageAtomicCompSwap(gimage1D image, int   P, uint compare, uint data)
  │                     ║  uint imageAtomicCompSwap(gimage2D image, ivec2 P, uint compare, uint data)
  │                     ║  uint imageAtomicCompSwap(gimage3D image, ivec3 P, uint compare, uint data)
  │                     ║  uint imageAtomicCompSwap(gimage2DRect image, ivec2 P, uint compare, uint data)
  │                     ║  uint imageAtomicCompSwap(gimageCube   image, ivec3 P, uint compare, uint data)
  │                     ║  uint imageAtomicCompSwap(gbufferImage image, int   P, uint compare, uint data)
  │                     ║  uint imageAtomicCompSwap(gimage1DArray   image, ivec2 P, uint compare, uint data)
  │                     ║  uint imageAtomicCompSwap(gimage2DArray   image, ivec3 P, uint compare, uint data)
  │                     ║  uint imageAtomicCompSwap(gimageCubeArray image, ivec3 P, uint compare, uint data)
  │                     ║  uint imageAtomicCompSwap(gimage2DMS image, ivec2 P, int sample, uint compare, uint data)
  │                     ║  uint imageAtomicCompSwap(gimage2DMSArray image, ivec3 P, int sample, uint compare, uint data)
  │                     ║  int  imageAtomicCompSwap(gimage1D image, int   P, int compare, int data)
  │                     ║  int  imageAtomicCompSwap(gimage2D image, ivec2 P, int compare, int data)
  │                     ║  int  imageAtomicCompSwap(gimage3D image, ivec3 P, int compare, int data)
  │                     ║  int  imageAtomicCompSwap(gimage2DRect image, ivec2 P, int compare, int data)
  │                     ║  int  imageAtomicCompSwap(gimageCube   image, ivec3 P, int compare, int data)
  │                     ║  int  imageAtomicCompSwap(gbufferImage image, int   P, int compare, int data)
  │                     ║  int  imageAtomicCompSwap(gimage1DArray   image, ivec2 P, int compare, int data)
  │                     ║  int  imageAtomicCompSwap(gimage2DArray   image, ivec3 P, int compare, int data)
  │                     ║  int  imageAtomicCompSwap(gimageCubeArray image, ivec3 P, int compare, int data)
  │                     ║  int  imageAtomicCompSwap(gimage2DMS image, ivec2 P, int sample, int compare, int data)
  │                     ║  int  imageAtomicCompSwap(gimage2DMSArray image, ivec3 P, int sample, int compare, int data)¶
  ├6║imageAtomicExchange║atomically store supplied data into memory and
  │                     ║return the original value from memory
  │                     ║  uint imageAtomicExchange(gimage1D image, int P, uint data)
  │                     ║  uint imageAtomicExchange(gimage2D image, ivec2 P, uint data)
  │                     ║  uint imageAtomicExchange(gimage3D image, ivec3 P, uint data)
  │                     ║  uint imageAtomicExchange(gimage2DRect image, ivec2 P, uint data)
  │                     ║  uint imageAtomicExchange(gimageCube image, ivec3 P, uint data)
  │                     ║  uint imageAtomicExchange(gbufferImage image, int P, uint data)
  │                     ║  uint imageAtomicExchange(gimage1DArray image, ivec2 P, uint data)
  │                     ║  uint imageAtomicExchange(gimage2DArray image, ivec3 P, uint data)
  │                     ║  uint imageAtomicExchange(gimageCubeArray image, ivec3 P, uint data)
  │                     ║  uint imageAtomicExchange(gimage2DMS image, ivec2 P, int sample, uint data)
  │                     ║  uint imageAtomicExchange(gimage2DMSArray image, ivec3 P, int sample, uint data)
  │                     ║  int  imageAtomicExchange(gimage1D image, int P, int data)
  │                     ║  int  imageAtomicExchange(gimage2D image, ivec2 P, int data)
  │                     ║  int  imageAtomicExchange(gimage3D image, ivec3 P, int data)
  │                     ║  int  imageAtomicExchange(gimage2DRect image, ivec2 P, int data)
  │                     ║  int  imageAtomicExchange(gimageCube image, ivec3 P, int data)
  │                     ║  int  imageAtomicExchange(gbufferImage image, int P, int data)
  │                     ║  int  imageAtomicExchange(gimage1DArray image, ivec2 P, int data)
  │                     ║  int  imageAtomicExchange(gimage2DArray image, ivec3 P, int data)
  │                     ║  int  imageAtomicExchange(gimageCubeArray image, ivec3 P, int data)
  │                     ║  int  imageAtomicExchange(gimage2DMS image, ivec2 P, int sample, int data)
  │                     ║  int  imageAtomicExchange(gimage2DMSArray image, ivec3 P, int sample, int data)
  │                     ║  int  imageAtomicExchange(gimage1D image, int P, float data)
  │                     ║  int  imageAtomicExchange(gimage2D image, ivec2 P, float data)
  │                     ║  int  imageAtomicExchange(gimage3D image, ivec3 P, float data)
  │                     ║  int  imageAtomicExchange(gimage2DRect image, ivec2 P, float data)
  │                     ║  int  imageAtomicExchange(gimageCube image, ivec3 P, float data)
  │                     ║  int  imageAtomicExchange(gbufferImage image, int P, float data)
  │                     ║  int  imageAtomicExchange(gimage1DArray image, ivec2 P, float data)
  │                     ║  int  imageAtomicExchange(gimage2DArray image, ivec3 P, float data)
  │                     ║  int  imageAtomicExchange(gimageCubeArray image, ivec3 P, float data)
  │                     ║  int  imageAtomicExchange(gimage2DMS image, ivec2 P, int sample, float data)
  │                     ║  int  imageAtomicExchange(gimage2DMSArray image, ivec3 P, int sample, float data)¶
  ├6║imageAtomicMax║atomically compute the minimum of a value with an existing
  │                ║value in memory, store that value and return the original value
  │                ║  uint imageAtomicMax(gimage1D image, int   P, uint data)
  │                ║  uint imageAtomicMax(gimage2D image, ivec2 P, uint data)
  │                ║  uint imageAtomicMax(gimage3D image, ivec3 P, uint data)
  │                ║  uint imageAtomicMax(gimage2DRect image, ivec2 P, uint data)
  │                ║  uint imageAtomicMax(gimageCube   image, ivec3 P, uint data)
  │                ║  uint imageAtomicMax(gbufferImage image, int   P, uint data)
  │                ║  uint imageAtomicMax(gimage1DArray   image, ivec2 P, uint data)
  │                ║  uint imageAtomicMax(gimage2DArray   image, ivec3 P, uint data)
  │                ║  uint imageAtomicMax(gimageCubeArray image, ivec3 P, uint data)
  │                ║  uint imageAtomicMax(gimage2DMS image, ivec2 P, int sample, uint data)
  │                ║  uint imageAtomicMax(gimage2DMSArray image, ivec3 P, int sample, uint data)
  │                ║  int  imageAtomicMax(gimage1D image, int   P, int data)
  │                ║  int  imageAtomicMax(gimage2D image, ivec2 P, int data)
  │                ║  int  imageAtomicMax(gimage3D image, ivec3 P, int data)
  │                ║  int  imageAtomicMax(gimage2DRect image, ivec2 P, int data)
  │                ║  int  imageAtomicMax(gimageCube   image, ivec3 P, int data)
  │                ║  int  imageAtomicMax(gbufferImage image, int   P, int data)
  │                ║  int  imageAtomicMax(gimage1DArray   image, ivec2 P, int data)
  │                ║  int  imageAtomicMax(gimage2DArray   image, ivec3 P, int data)
  │                ║  int  imageAtomicMax(gimageCubeArray image, ivec3 P, int data)
  │                ║  int  imageAtomicMax(gimage2DMS image, ivec2 P, int sample, int data)
  │                ║  int  imageAtomicMax(gimage2DMSArray image, ivec3 P, int sample, int data)¶
  ├6║imageAtomicMin║atomically compute the minimum of a value with an existing
  │                ║value in memory, store that value and return the original value
  │                ║  uint imageAtomicMin(gimage1D image, int   P, uint data)
  │                ║  uint imageAtomicMin(gimage2D image, ivec2 P, uint data)
  │                ║  uint imageAtomicMin(gimage3D image, ivec3 P, uint data)
  │                ║  uint imageAtomicMin(gimage2DRect image, ivec2 P, uint data)
  │                ║  uint imageAtomicMin(gimageCube   image, ivec3 P, uint data)
  │                ║  uint imageAtomicMin(gbufferImage image, int   P, uint data)
  │                ║  uint imageAtomicMin(gimage1DArray   image, ivec2 P, uint data)
  │                ║  uint imageAtomicMin(gimage2DArray   image, ivec3 P, uint data)
  │                ║  uint imageAtomicMin(gimageCubeArray image, ivec3 P, uint data)
  │                ║  uint imageAtomicMin(gimage2DMS image, ivec2 P, int sample, uint data)
  │                ║  uint imageAtomicMin(gimage2DMSArray image, ivec3 P, int sample, uint data)
  │                ║  int  imageAtomicMin(gimage1D image, int   P, int data)
  │                ║  int  imageAtomicMin(gimage2D image, ivec2 P, int data)
  │                ║  int  imageAtomicMin(gimage3D image, ivec3 P, int data)
  │                ║  int  imageAtomicMin(gimage2DRect image, ivec2 P, int data)
  │                ║  int  imageAtomicMin(gimageCube   image, ivec3 P, int data)
  │                ║  int  imageAtomicMin(gbufferImage image, int   P, int data)
  │                ║  int  imageAtomicMin(gimage1DArray   image, ivec2 P, int data)
  │                ║  int  imageAtomicMin(gimage2DArray   image, ivec3 P, int data)
  │                ║  int  imageAtomicMin(gimageCubeArray image, ivec3 P, int data)
  │                ║  int  imageAtomicMin(gimage2DMS image, ivec2 P, int sample, int data)
  │                ║  int  imageAtomicMin(gimage2DMSArray image, ivec3 P, int sample, int data)¶
  ├6║imageAtomicOr║atomically compute the logical OR of a value with an existing
  │               ║value in memory, store that value and return the original value
  │               ║  uint imageAtomicOr(gimage1D image, int   P, uint data)
  │               ║  uint imageAtomicOr(gimage2D image, ivec2 P, uint data)
  │               ║  uint imageAtomicOr(gimage3D image, ivec3 P, uint data)
  │               ║  uint imageAtomicOr(gimage2DRect image, ivec2 P, uint data)
  │               ║  uint imageAtomicOr(gimageCube   image, ivec3 P, uint data)
  │               ║  uint imageAtomicOr(gbufferImage image, int   P, uint data)
  │               ║  uint imageAtomicOr(gimage1DArray   image, ivec2 P, uint data)
  │               ║  uint imageAtomicOr(gimage2DArray   image, ivec3 P, uint data)
  │               ║  uint imageAtomicOr(gimageCubeArray image, ivec3 P, uint data)
  │               ║  uint imageAtomicOr(gimage2DMS image, ivec2 P, int sample, uint data)
  │               ║  uint imageAtomicOr(gimage2DMSArray image, ivec3 P, int sample, uint data)
  │               ║  int  imageAtomicOr(gimage1D image, int   P, int data)
  │               ║  int  imageAtomicOr(gimage2D image, ivec2 P, int data)
  │               ║  int  imageAtomicOr(gimage3D image, ivec3 P, int data)
  │               ║  int  imageAtomicOr(gimage2DRect image, ivec2 P, int data)
  │               ║  int  imageAtomicOr(gimageCube   image, ivec3 P, int data)
  │               ║  int  imageAtomicOr(gbufferImage image, int   P, int data)
  │               ║  int  imageAtomicOr(gimage1DArray   image, ivec2 P, int data)
  │               ║  int  imageAtomicOr(gimage2DArray   image, ivec3 P, int data)
  │               ║  int  imageAtomicOr(gimageCubeArray image, ivec3 P, int data)
  │               ║  int  imageAtomicOr(gimage2DMS image, ivec2 P, int sample, int data)
  │               ║  int  imageAtomicOr(gimage2DMSArray image, ivec3 P, int sample, int data)¶
  ├6║imageAtomicXor║atomically compute the logical exclusive OR of a value
  │                ║with an existing value in memory, store that value and
  │                ║return the original value
  │                ║  uint imageAtomicXor(gimage1D image, int   P, uint data)
  │                ║  uint imageAtomicXor(gimage2D image, ivec2 P, uint data)
  │                ║  uint imageAtomicXor(gimage3D image, ivec3 P, uint data)
  │                ║  uint imageAtomicXor(gimage2DRect image, ivec2 P, uint data)
  │                ║  uint imageAtomicXor(gimageCube   image, ivec3 P, uint data)
  │                ║  uint imageAtomicXor(gbufferImage image, int   P, uint data)
  │                ║  uint imageAtomicXor(gimage1DArray   image, ivec2 P, uint data)
  │                ║  uint imageAtomicXor(gimage2DArray   image, ivec3 P, uint data)
  │                ║  uint imageAtomicXor(gimageCubeArray image, ivec3 P, uint data)
  │                ║  uint imageAtomicXor(gimage2DMS image, ivec2 P, int sample, uint data)
  │                ║  uint imageAtomicXor(gimage2DMSArray image, ivec3 P, int sample, uint data)
  │                ║  int  imageAtomicXor(gimage1D image, int   P, int data)
  │                ║  int  imageAtomicXor(gimage2D image, ivec2 P, int data)
  │                ║  int  imageAtomicXor(gimage3D image, ivec3 P, int data)
  │                ║  int  imageAtomicXor(gimage2DRect image, ivec2 P, int data)
  │                ║  int  imageAtomicXor(gimageCube   image, ivec3 P, int data)
  │                ║  int  imageAtomicXor(gbufferImage image, int   P, int data)
  │                ║  int  imageAtomicXor(gimage1DArray   image, ivec2 P, int data)
  │                ║  int  imageAtomicXor(gimage2DArray   image, ivec3 P, int data)
  │                ║  int  imageAtomicXor(gimageCubeArray image, ivec3 P, int data)
  │                ║  int  imageAtomicXor(gimage2DMS image, ivec2 P, int sample, int data)
  │                ║  int  imageAtomicXor(gimage2DMSArray image, ivec3 P, int sample, int data)¶
  ├6║imageLoad║load a single texel from an image
  │           ║  gvec4 imageLoad(gimage1D image, int   P)
  │           ║  gvec4 imageLoad(gimage2D image, ivec2 P)
  │           ║  gvec4 imageLoad(gimage3D image, ivec3 P)
  │           ║  gvec4 imageLoad(gimage2DRect image, ivec2 P)
  │           ║  gvec4 imageLoad(gimageCube   image, ivec3 P)
  │           ║  gvec4 imageLoad(gbufferImage image, int   P)
  │           ║  gvec4 imageLoad(gimage1DArray   image, ivec2 P)
  │           ║  gvec4 imageLoad(gimage2DArray   image, ivec3 P)
  │           ║  gvec4 imageLoad(gimageCubeArray image, ivec3 P)
  │           ║  gvec4 imageLoad(gimage2DMS image, ivec2 P, int sample)
  │           ║  gvec4 imageLoad(gimage2DMSArray image, ivec3 P, int sample)¶
  ├6║imageSamples║return the number of samples of an image
  │              ║  int imageSamples(gimage2DMS image)
  │              ║  int imageSamples(gimage2DMSArray image)¶
  ├6║imageSize║retrieve the dimensions of an image
  │           ║  int   imageSize(gimage1D image)
  │           ║  ivec2 imageSize(gimage2D image)
  │           ║  ivec3 imageSize(gimage3D image)
  │           ║  ivec2 imageSize(gimageCube image)
  │           ║  ivec3 imageSize(gimageCubeArray image)
  │           ║  ivec2 imageSize(gimageRect image)
  │           ║  ivec2 imageSize(gimage1DArray image)
  │           ║  ivec3 imageSize(gimage2DArray image)
  │           ║  int   imageSize(gimageBuffer image)
  │           ║  ivec2 imageSize(gimage2DMS image)
  │           ║  ivec3 imageSize(gimage2DMSArray image)¶
  ├6║imageStore║write a single texel into an image
  │            ║  void imageStore(gimage1D image, int   P, gvec4 data)
  │            ║  void imageStore(gimage2D image, ivec2 P, gvec4 data)
  │            ║  void imageStore(gimage3D image, ivec3 P, gvec4 data)
  │            ║  void imageStore(gimage2DRect image, ivec2 P, gvec4 data)
  │            ║  void imageStore(gimageCube   image, ivec3 P, gvec4 data)
  │            ║  void imageStore(gbufferImage image, int   P, gvec4 data)
  │            ║  void imageStore(gimage1DArray   image, ivec2 P, gvec4 data)
  │            ║  void imageStore(gimage2DArray   image, ivec3 P, gvec4 data)
  │            ║  void imageStore(gimageCubeArray image, ivec3 P, gvec4 data)
  │            ║  void imageStore(gimage2DMS image, ivec2 P, int sample, gvec4 data)
  │            ║  void imageStore(gimage2DMSArray image, ivec3 P, int sample, gvec4 data)¶
  ├6║imulExtended║perform a 32- by 32-bit multiply to produce a 64-bit result
  │              ║  void imulExtended(genIType x, genIType y, out genIType msb, out genIType lsb)¶
  ├6║intBitsToFloat║produce a floating point using an
  │                ║encoding supplied as an integer
  │                ║  genType intBitsToFloat(genIType x)¶
  ├6║interpolateAtCentroid║sample a varying at the centroid of a pixel
  │                       ║  float interpolateAtCentroid(float interpolant)
  │                       ║  vec2  interpolateAtCentroid(vec2  interpolant)
  │                       ║  vec3  interpolateAtCentroid(vec3  interpolant)
  │                       ║  vec4  interpolateAtCentroid(vec4  interpolant)¶
  ├6║interpolateAtOffset║sample a varying at specified offset from the center of a pixel
  │                     ║  float interpolateAtOffset(float interpolant, vec2 offset)
  │                     ║  vec2  interpolateAtOffset(vec2  interpolant, vec2 offset)
  │                     ║  vec3  interpolateAtOffset(vec3  interpolant, vec2 offset)
  │                     ║  vec4  interpolateAtOffset(vec4  interpolant, vec2 offset)¶
  ├6║interpolateAtSample║sample a varying at the location of a specified sample
  │                     ║  float interpolateAtSample(float interpolant, int sample)
  │                     ║  vec2  interpolateAtSample(vec2  interpolant, int sample)
  │                     ║  vec3  interpolateAtSample(vec3  interpolant, int sample)
  │                     ║  vec4  interpolateAtSample(vec4  interpolant, int sample)¶
  ├6║inverse║calculate the inverse of a matrix
  │         ║  mat2  inverse(mat2  m)
  │         ║  mat3  inverse(mat3  m)
  │         ║  mat4  inverse(mat4  m)
  │         ║  dmat2 inverse(dmat2 m)
  │         ║  dmat3 inverse(dmat3 m)
  │         ║  dmat4 inverse(dmat4 m)¶
  ├6║inversesqrt║return the inverse of the square root of the parameter
  │             ║  genType  inversesqrt(genType  x)
  │             ║  genDType inversesqrt(genDType x)¶
  ├6║isinf║determine whether the parameter is positive or negative infinity
  │       ║  genBType isinf(genType x)
  │       ║  genBType isinf(genDType x)¶
  ├6║isnan║determine whether the parameter is a number
  │       ║  genBType isnan(genType x)
  │       ║  genBType isnan(genDType x)¶
  ├6║ldexp║assemble a floating point number from a value and exponent
  │       ║  genType  ldexp(genType  x, genIType exp)
  │       ║  genDType ldexp(genDType x, genIType exp)¶
  ├6║length║calculate the length of a vector
  │        ║  float  length(genType  x)
  │        ║  double length(genDType x)¶
  ├6║lessThan║perform a component-wise less-than comparison of two vectors
  │          ║  bvec lessThan(vec  x, vec  y)
  │          ║  bvec lessThan(ivec x, ivec y)
  │          ║  bvec lessThan(uvec x, uvec y)¶
  ├6║lessThanEqual║perform a component-wise less-than-or-equal comparison of two vectors
  │               ║  bvec lessThanEqual(vec  x, vec  y)
  │               ║  bvec lessThanEqual(ivec x, ivec y)
  │               ║  bvec lessThanEqual(uvec x, uvec y)¶
  ├6║log║return the natural logarithm of the parameter
  │     ║  genType log(genType x)¶
  ├6║log2║return the base 2 logarithm of the parameter
  │      ║  genType log2(genType x)¶
  ├6║matrixCompMult║perform a component-wise multiplication of two matrices
  │                ║  mat  matrixCompMult(mat  x, mat  y)
  │                ║  dmat matrixCompMult(dmat x, dmat y)¶
  ├6║max║return the greater of two values
  │     ║  genType  max(genType  x, genType  y)
  │     ║  genType  max(genType  x, float    y)
  │     ║  genDType max(genDType x, genDType y)
  │     ║  genDType max(genDType x, double   y)
  │     ║  genIType max(genIType x, genIType y)
  │     ║  genIType max(genIType x, int      y)
  │     ║  genUType max(genUType x, genUType y)
  │     ║  genUType max(genUType x, uint     y)¶
  ├6║memoryBarrier║controls the ordering of memory transactions
  │               ║issued by a single shader invocation
  │               ║  uint memoryBarrier(void)¶
  ├6║memoryBarrierAtomicCounter║controls the ordering of operations on atomic
  │                            ║counters issued by a single shader invocation
  │                            ║  void memoryBarrierAtomicCounter(void)¶
  ├6║memoryBarrierBuffer║controls the ordering of operations on buffer
  │                     ║variables issued by a single shader invocation
  │                     ║  void memoryBarrierBuffer(void)¶
  ├6║memoryBarrierImage║controls the ordering of operations on image
  │                    ║variables issued by a single shader invocation
  │                    ║  void memoryBarrierImage(void)¶
  ├6║memoryBarrierShared║controls the ordering of operations on shared
  │                     ║variables issued by a single shader invocation
  │                     ║  void memoryBarrierShared(void)¶
  ├6║min║return the lesser of two values
  │     ║  genType  min(genType  x, genType  y)
  │     ║  genType  min(genType  x, float    y)
  │     ║  genDType min(genDType x, genDType y)
  │     ║  genDType min(genDType x, double   y)
  │     ║  genIType min(genIType x, genIType y)
  │     ║  genIType min(genIType x, int      y)
  │     ║  genUType min(genUType x, genUType y)
  │     ║  genUType min(genUType x, uint     y)¶
  ├6║mix║linearly interpolate between two values
  │     ║  genType  mix(genType  x, genType  y, genType  a)
  │     ║  genType  mix(genType  x, genType  y, float    a)
  │     ║  genDType mix(genDType x, genDType y, genDType a)
  │     ║  genDType mix(genDType x, genDType y, double   a)
  │     ║  genType  mix(genType  x, genType  y, genBType a)
  │     ║  genDType mix(genDType x, genDType y, genBType a)
  │     ║  genIType mix(genIType x, genIType y, genBType a)
  │     ║  genUType mix(genUType x, genUType y, genBType a)
  │     ║  genBType mix(genBType x, genBType y, genBType a)¶
  ├6║mod║compute value of one parameter modulo another
  │     ║  genType  mod(genType  x, float    y)
  │     ║  genType  mod(genType  x, genType  y)
  │     ║  genDType mod(genDType x, double   y)
  │     ║  genDType mod(genDType x, genDType y)¶
  ├6║modf║separate a value into its integer and fractional components
  │      ║  genType  modf(genType  x, out genType  i)
  │      ║  genDType modf(genDType x, out genDType i)¶
  ├6║noise1║generate values with a pseudo-random noise function
  │        ║  float noise1(genType x)¶
  ├6║noise2║generate values with a pseudo-random noise function
  │        ║  vec2 noise2(genType x)¶
  ├6║noise3║generate values with a pseudo-random noise function
  │        ║  vec3 noise3(genType x)¶
  ├6║noise4║generate values with a pseudo-random noise function
  │        ║  vec4 noise4(genType x)¶
  ├6║normalize║calculate the normalize product of two vectors
  │           ║  genType  normalize(genType  v)
  │           ║  genDType normalize(genDType v)¶
  ├6║not║logically invert a boolean vector
  │     ║  bvec not(bvec x)¶
  ├6║notEqual║perform a component-wise not-equal-to comparison of two vectors
  │          ║   bvec notEqual(vec x, vec y)
  │          ║   bvec notEqual(ivec x, ivec y)
  │          ║   bvec notEqual(uvec x, uvec y)¶
  ├6║outerProduct║calculate the outer product of a pair of vectors
  │              ║  mat2    outerProduct(vec2  c, vec2  r)
  │              ║  mat3    outerProduct(vec3  c, vec3  r)
  │              ║  mat4    outerProduct(vec4  c, vec4  r)
  │              ║  mat2x3  outerProduct(vec3  c, vec2  r)
  │              ║  mat3x2  outerProduct(vec2  c, vec3  r)
  │              ║  mat2x4  outerProduct(vec4  c, vec2  r)
  │              ║  mat4x2  outerProduct(vec2  c, vec4  r)
  │              ║  mat3x4  outerProduct(vec4  c, vec3  r)
  │              ║  mat4x3  outerProduct(vec3  c, vec4  r)
  │              ║  dmat2   outerProduct(dvec2 c, dvec2 r)
  │              ║  dmat3   outerProduct(dvec3 c, dvec3 r)
  │              ║  dmat4   outerProduct(dvec4 c, dvec4 r)
  │              ║  dmat2x3 outerProduct(dvec3 c, dvec2 r)
  │              ║  dmat3x2 outerProduct(dvec2 c, dvec3 r)
  │              ║  dmat2x4 outerProduct(dvec4 c, dvec2 r)
  │              ║  dmat4x2 outerProduct(dvec2 c, dvec4 r)
  │              ║  dmat3x4 outerProduct(dvec4 c, dvec3 r)
  │              ║  dmat4x3 outerProduct(dvec3 c, dvec4 r)¶
  ├6║packDouble2x32║create a double-precision value
  │                ║from a pair of unsigned integers
  │                ║  double packDouble2x32(uvec2 v)¶
  ├6║packHalf2x16║convert two 32-bit floating-point
  │              ║quantities to16-bit quantities and
  │              ║pack them into a single 32-bit integer
  │              ║  uint packHalf2x16(vec2 v)¶
  ├6║packSnorm2x16║pack floating-point values into an unsigned integer
  │               ║  uint packSnorm2x16(vec2 v)¶
  ├6║packSnorm4x8║pack floating-point values into an unsigned integer
  │              ║  uint packSnorm4x8(vec4 v)¶
  ├6║packUnorm2x16║pack floating-point values into an unsigned integer
  │               ║  uint packUnorm2x16(vec2 v)¶
  ├6║packUnorm4x8║pack floating-point values into an unsigned integer
  │              ║  uint packUnorm4x8(vec4 v)¶
  ├6║pow║return the value of the first parameter raised to the power of the second
  │     ║  genType pow(genType x, genType y)¶
  ├6║radians║convert a quantity in degrees to radians
  │         ║  genType radians(genType degrees)¶
  ├6║reflect║calculate the reflection direction for an incident vector
  │         ║  genType  reflect(genType  I, genType  N)
  │         ║  genDType reflect(genDType I, genDType N)¶
  ├6║refract║calculate the refraction direction for an incident vector
  │         ║  genType  refract(genType  I, genType  N, float eta)
  │         ║  genDType refract(genDType I, genDType N, float eta)¶
  ├6║round║find the nearest integer less than or equal to the parameter
  │       ║  genType  round(genType  x)
  │       ║  genDType round(genDType x)¶
  ├6║roundEven║find the nearest even integer to the parameter
  │           ║  genType  roundEven(genType  x)
  │           ║  genDType roundEven(genDType x)¶
  ├6║sign║extract the sign of the parameter
  │      ║  genType  sign(genType  x)
  │      ║  genIType sign(genIType x)
  │      ║  genDType sign(genDType x)¶
  ├6║sin║return the sine of the parameter
  │     ║  genType  sin(genType  x)
  │     ║  genDType sin(genDType x)¶
  ├6║sinh║return the hyperbolic sine of the parameter
  │      ║  genType  sinh(genType  x)
  │      ║  genDType sinh(genDType x)¶
  ├6║sqrt║return the square root of the parameter
  │      ║  genType  sqrt(genType  x)
  │      ║  genDType sqrt(genDType x)¶
  ├6║step║generate a step function by comparing two values
  │      ║  genType step(genType edge, genType x)
  │      ║  genType step(float edge, genType x)
  │      ║  genDType step(genDType edge, genDType x)
  │      ║  genDType step(double edge, genDType x)¶
  ├6║tan║return the tangent of the parameter
  │     ║  genType tan(genType x)¶
  ├6║tanh║return the hyperbolic tangent of the parameter
  │      ║  genType tanh(genType x)¶
  ├6║texelFetch║perform a lookup of a single texel within a texture
  │            ║  gvec4 texelFetch(gsampler1D sampler, int P, int lod)
  │            ║  gvec4 texelFetch(gsampler2D sampler, ivec2 P, int lod)
  │            ║  gvec4 texelFetch(gsampler3D sampler, ivec3 P, int lod)
  │            ║  gvec4 texelFetch(gsampler2DRect sampler, ivec2 P)
  │            ║  gvec4 texelFetch(gsampler1DArray sampler, ivec2 P, int lod)
  │            ║  gvec4 texelFetch(gsampler2DArray sampler, ivec3 P, int lod)
  │            ║  gvec4 texelFetch(gsamplerBuffer sampler, int P)
  │            ║  gvec4 texelFetch(gsampler2DMS sampler, ivec2 P, sample sample)
  │            ║  gvec4 texelFetch(gsampler2DMSArray sampler, ivec3 P, sample sample)¶
  ├6║texelFetchOffset║perform a lookup of a single texel within a texture with an offset
  │                  ║  gvec4 texelFetchOffset(gsampler1D sampler, int P, int lod, int offset)
  │                  ║  gvec4 texelFetchOffset(gsampler2D sampler, ivec2 P, int lod, int offset)
  │                  ║  gvec4 texelFetchOffset(gsampler3D sampler, ivec3 P, int lod, int offset)
  │                  ║  gvec4 texelFetchOffset(gsampler2DRect  sampler, ivec2 P, int offset)
  │                  ║  gvec4 texelFetchOffset(gsampler1DArray sampler, ivec2 P, int lod, int offset)
  │                  ║  gvec4 texelFetchOffset(gsampler2DArray sampler, ivec3 P, int lod, int offset)¶
  ├6║texture║retrieves texels from a texture
  │         ║  gvec4 texture(gsampler1D sampler, float P, [float bias])
  │         ║  gvec4 texture(gsampler2D sampler, vec2 P, [float bias])
  │         ║  gvec4 texture(gsampler3D sampler, vec3 P, [float bias])
  │         ║  gvec4 texture(gsamplerCube sampler, vec3  P, [float bias])
  │         ║  float texture(sampler1DShadow sampler, vec3 P, [float bias])
  │         ║  float texture(sampler2DShadow sampler, vec3 P, [float bias])
  │         ║  float texture(samplerCubeShadow sampler, vec3 P, [float bias])
  │         ║  gvec4 texture(gsampler1DArray sampler, vec2 P, [float bias])
  │         ║  gvec4 texture(gsampler2DArray sampler, vec3 P, [float bias])
  │         ║  gvec4 texture(gsamplerCubeArray sampler, vec4 P, [float bias])
  │         ║  float texture(sampler1DArrayShadow sampler, vec3 P, [float bias])
  │         ║  float texture(gsampler2DArrayShadow sampler, vec4 P, [float bias])
  │         ║  gvec4 texture(gsampler2DRect sampler, vec2 P)
  │         ║  float texture(sampler2DRectShadow sampler, vec3 P)
  │         ║  float texture(gsamplerCubeArrayShadow sampler, vec4 P, float compare)¶
  ├6║textureGather║gathers four texels from a texture
  │               ║  gvec4 textureGather(gsampler2D sampler, vec2 P, [int comp])
  │               ║  gvec4 textureGather(gsampler2DArray sampler, vec3 P, [int comp])
  │               ║  gvec4 textureGather(gsamplerCube sampler, vec3 P, [int comp])
  │               ║  gvec4 textureGather(gsamplerCubeArray sampler, vec4 P, [int comp])
  │               ║  gvec4 textureGather(gsampler2DRect sampler, vec3 P, [int comp])
  │               ║  vec4  textureGather(gsampler2DShadow  sampler, vec2 P, float refZ)
  │               ║  vec4  textureGather(gsampler2DArrayShadow sampler, vec3 P, float refZ)
  │               ║  vec4  textureGather(gsamplerCubeShadow sampler, vec3 P, float refZ)
  │               ║  vec4  textureGather(gsamplerCubeArrayShadow sampler, vec4 P, float refZ)
  │               ║  vec4  textureGather(gsampler2DRectShadow sampler, vec3 P, float refZ)¶
  ├6║textureGatherOffset║gathers four texels from a texture with offset
  │                     ║  gvec4 textureGatherOffset(gsampler2D sampler, vec2 P, ivec2 offset, [int comp])
  │                     ║  gvec4 textureGatherOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, [int comp])
  │                     ║  gvec4 textureGatherOffset(gsampler2DRect sampler, vec3 P, ivec2 offset, [int comp])
  │                     ║  vec4  textureGatherOffset(gsampler2DShadow sampler, vec2 P, float refZ, ivec2 offset)
  │                     ║  vec4  textureGatherOffset(gsampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offset)
  │                     ║  vec4  textureGatherOffset(gsampler2DRectShadow  sampler, vec3 P, float refZ, ivec2 offset)¶
  ├6║textureGatherOffsets║gathers four texels from a texture with an array of offsets
  │                      ║  gvec4 textureGatherOffsets(gsampler2D sampler, vec2 P, ivec2 offsets[3], [int comp])
  │                      ║  gvec4 textureGatherOffsets(gsampler2DArray sampler, vec3 P, ivec2 offsets[3], [int comp])
  │                      ║  gvec4 textureGatherOffsets(gsampler2DRect sampler, vec3 P, ivec2 offsets[3], [int comp])
  │                      ║  vec4  textureGatherOffsets(gsampler2DShadow sampler, vec2 P, float refZ, ivec2 offsets[3])
  │                      ║  vec4  textureGatherOffsets(gsampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offsets[3])
  │                      ║  vec4  textureGatherOffsets(gsampler2DRectShadow  sampler, vec3 P, float refZ, ivec2 offsets[3])¶
  ├6║textureGrad║perform a texture lookup with explicit gradients
  │             ║  gvec4 textureGrad(gsampler1D sampler, float P, float dPdx, float dPdy)
  │             ║  gvec4 textureGrad(gsampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy)
  │             ║  gvec4 textureGrad(gsampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy)
  │             ║  gvec4 textureGrad(gsamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy)
  │             ║  gvec4 textureGrad(gsampler2DRect sampler, vec2 P, vec2 dPdx, vec2 dPdy)
  │             ║  float textureGrad(gsampler2DRectShadow sampler, vec2 P, vec2  dPdx, vec2 dPdy)
  │             ║  float textureGrad(sampler1DShadow sampler, vec3 P, float dPdx, float dPdy)
  │             ║  float textureGrad(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy)
  │             ║  gvec4 textureGrad(gsampler1DArray sampler, vec2 P, float dPdx, float dPdy)
  │             ║  gvec4 textureGrad(gsampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy)
  │             ║  float textureGrad(sampler1DArrayShadow sampler, vec3 P, float dPdx, float dPdy)
  │             ║  gvec4 textureGrad(gsamplerCubeArray sampler, vec4  P, vec3 dPdx, vec3 dPdy)¶
  ├6║textureLod║perform a texture lookup with explicit level-of-detail
  │            ║  gvec4 textureLod(gsampler1D sampler, float P, float lod)
  │            ║  gvec4 textureLod(gsampler2D sampler, vec2 P, float lod)
  │            ║  gvec4 textureLod(gsampler3D sampler, vec3 P, float lod)
  │            ║  gvec4 textureLod(gsamplerCube sampler, vec3 P, float lod)
  │            ║  float textureLod(sampler1DShadow sampler, vec3 P, float lod)
  │            ║  float textureLod(sampler2DShadow sampler, vec4 P, float lod)
  │            ║  gvec4 textureLod(gsampler1DArray sampler, vec2 P, float lod)
  │            ║  gvec4 textureLod(gsampler2DArray sampler, vec3 P, float lod)
  │            ║  float textureLod(sampler1DArrayShadow sampler, vec3 P, float lod)
  │            ║  gvec4 textureLod(gsamplerCubeArray sampler, vec4 P, float lod)¶
  ├6║textureOffset║perform a texture lookup with offset
  │               ║  gvec4 textureOffset(gsampler1D sampler, float P, int offset, [float bias])
  │               ║  gvec4 textureOffset(gsampler2D sampler, vec2 P, ivec2 offset, [float bias])
  │               ║  gvec4 textureOffset(gsampler3D sampler, vec3 P, ivec3 offset, [float bias])
  │               ║  gvec4 textureOffset(gsampler2DRect sampler, vec2 P, ivec2 offset)
  │               ║  float textureOffset(sampler2DRectShadow  sampler, vec3  P, ivec2 offset)
  │               ║  float textureOffset(sampler1DShadow sampler, vec3 P, int offset, [float bias])
  │               ║  float textureOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, [float bias])
  │               ║  gvec4 textureOffset(gsampler1DArray sampler, vec2 P, int offset, [float bias])
  │               ║  gvec4 textureOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, [float bias])
  │               ║  float textureOffset(sampler1DArrayShadow sampler, vec3 P, int offset)
  │               ║  float textureOffset(sampler2DArrayShadow sampler, vec4 P, vec2 offset)¶
  ├6║textureProj║perform a texture lookup with projection
  │             ║  vec4  textureProj(gsampler1D sampler, vec2 P, [float bias])
  │             ║  gvec4 textureProj(gsampler1D sampler, vec4 P, [float bias])
  │             ║  gvec4 textureProj(gsampler2D sampler, vec3 P, [float bias])
  │             ║  gvec4 textureProj(gsampler2D sampler, vec4 P, [float bias])
  │             ║  gvec4 textureProj(gsampler3D sampler, vec4 P, [float bias])
  │             ║  float textureProj(sampler1DShadow sampler, vec4 P, [float bias])
  │             ║  float textureProj(sampler2DShadow sampler, vec4 P, [float bias])
  │             ║  gvec4 textureProj(gsampler2DRect sampler, vec3 P)
  │             ║  gvec4 textureProj(gsampler2DRect sampler, vec4 P)
  │             ║  float textureProj(gsampler2DRectShadow sampler, vec4 P)¶
  ├6║textureProjGrad║perform a texture lookup with projection and explicit gradients
  │                 ║  gvec4 textureProjGrad(gsampler1D sampler, vec2 P, float pDx, float pDy)
  │                 ║  gvec4 textureProjGrad(gsampler1D sampler, vec4 P, float pDx, float pDy)
  │                 ║  gvec4 textureProjGrad(gsampler2D sampler, vec3 P, vec2 pDx, vec2 pDy)
  │                 ║  gvec4 textureProjGrad(gsampler2D sampler, vec4 P, vec2 pDx, vec2 pDy)
  │                 ║  gvec4 textureProjGrad(gsampler3D sampler, vec4 P, vec3 pDx, vec3 pDy)
  │                 ║  float textureProjGrad(sampler1DShadow sampler, vec4 P, float pDx, float pDy)
  │                 ║  float textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 pDx, vec2 pDy)
  │                 ║  gvec4 textureProjGrad(gsampler2DRect sampler, vec3 P, vec2 pDx, vec2 pDy)
  │                 ║  gvec4 textureProjGrad(gsampler2DRect sampler, vec4 P, vec2 pDx, vec2 pDy)
  │                 ║  float textureProjGrad(gsampler2DRectShadow sampler, vec4 P, vec2 pDx, vec2 pDy)¶
  ├6║textureProjGradOffset║perform a texture lookup with projection, explicit gradients and offset
  │                       ║  gvec4 textureProjGradOffset(gsampler1D sampler, vec2 P, float dPdx, float dPdy, int offset)
  │                       ║  gvec4 textureProjGradOffset(gsampler1D sampler, vec4 P, float dPdx, float dPdy, int offset)
  │                       ║  gvec4 textureProjGradOffset(gsampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
  │                       ║  gvec4 textureProjGradOffset(gsampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
  │                       ║  gvec4 textureProjGradOffset(gsampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset)
  │                       ║  float textureProjGradOffset(sampler1DShadow sampler, vec4 P, float dPdx, float dPdy, int offset)
  │                       ║  float textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
  │                       ║  gvec4 textureProjGradOffset(gsampler2DRect sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
  │                       ║  gvec4 textureProjGradOffset(gsampler2DRect sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
  │                       ║  float textureProjGradOffset(gsampler2DRectShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)¶
  ├6║textureProjLod║perform a texture lookup with projection and explicit level-of-detail
  │                ║  vec4  textureProjLod(gsampler1D sampler, vec2 P, float lod)
  │                ║  gvec4 textureProjLod(gsampler1D sampler, vec4 P, float lod)
  │                ║  gvec4 textureProjLod(gsampler2D sampler, vec3 P, float lod)
  │                ║  gvec4 textureProjLod(gsampler2D sampler, vec4 P, float lod)
  │                ║  gvec4 textureProjLod(gsampler3D sampler, vec4 P, float lod)
  │                ║  float textureProjLod(sampler1DShadow sampler, vec4 P, float lod)
  │                ║  float textureProjLod(sampler2DShadow sampler, vec4 P, float lod)¶
  ├6║textureProjLodOffset║perform a texture lookup with projection and explicit level-of-detail and offset
  │                      ║  gvec4 textureProjLodOffset(gsampler1D sampler, vec2 P, float lod, int offset)
  │                      ║  gvec4 textureProjLodOffset(gsampler1D sampler, vec4 P, float lod, int offset)
  │                      ║  gvec4 textureProjLodOffset(gsampler2D sampler, vec3 P, float lod, ivec2 offset)
  │                      ║  gvec4 textureProjLodOffset(gsampler2D sampler, vec4 P, float lod, ivec2 offset)
  │                      ║  gvec4 textureProjLodOffset(gsampler3D sampler, vec4 P, float lod, ivec3 offset)
  │                      ║  float textureProjLodOffset(sampler1DShadow sampler, vec4 P, float lod, int   offset)
  │                      ║  float textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset)¶
  ├6║textureProjOffset║perform a texture lookup with projection and offset
  │                   ║  gvec4 textureProjOffset(gsampler1D sampler, vec2 P, int offset, [float bias])
  │                   ║  gvec4 textureProjOffset(gsampler1D sampler, vec4 P, int offset, [float bias])
  │                   ║  gvec4 textureProjOffset(gsampler2D sampler, vec3 P, ivec2 offset, [float bias])
  │                   ║  gvec4 textureProjOffset(gsampler2D sampler, vec4 P, ivec2 offset, [float bias])
  │                   ║  gvec4 textureProjOffset(gsampler3D sampler, vec4 P, ivec3 offset, [float bias])
  │                   ║  float textureProjOffset(sampler1DShadow sampler, vec4 P, int   offset, [float bias])
  │                   ║  float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, [float bias])
  │                   ║  gvec4 textureProjOffset(gsampler2DRect sampler, vec3 P, ivec2 offset)
  │                   ║  gvec4 textureProjOffset(gsampler2DRect sampler, vec4 P, ivec2 offset)
  │                   ║  float textureProjOffset(gsampler2DRectShadow sampler, vec4 P, ivec2 offset)¶
  ├6║textureQueryLevels║compute the number of accessible mipmap levels of a texture
  │                    ║  int textureQueryLevels(gsampler1D sampler)
  │                    ║  int textureQueryLevels(gsampler2D sampler)
  │                    ║  int textureQueryLevels(gsampler3D sampler)
  │                    ║  int textureQueryLevels(gsamplerCube sampler)
  │                    ║  int textureQueryLevels(gsampler1DArray sampler)
  │                    ║  int textureQueryLevels(gsampler2DDArray sampler)
  │                    ║  int textureQueryLevels(gsamplerCubeArray sampler)
  │                    ║  int textureQueryLevels(gsampler1DShadow sampler)
  │                    ║  int textureQueryLevels(gsampler2DShadow sampler)
  │                    ║  int textureQueryLevels(gsamplerCubeShadow sampler)
  │                    ║  int textureQueryLevels(gsampler1DArrayShadow sampler)
  │                    ║  int textureQueryLevels(gsampler2DArrayShadow sampler)
  │                    ║  int textureQueryLevels(gsamplerCubeArrayShadow sampler)¶
  ├6║textureQueryLod║compute the level-of-detail that would be used to sample from a texture
  │                 ║  vec2 textureQueryLod(gsampler1D sampler, float P)
  │                 ║  vec2 textureQueryLod(gsampler2D sampler, vec2  P)
  │                 ║  vec2 textureQueryLod(gsampler3D sampler, vec3  P)
  │                 ║  vec2 textureQueryLod(gsamplerCube sampler, vec3  P)
  │                 ║  vec2 textureQueryLod(gsampler1DArray sampler, float P)
  │                 ║  vec2 textureQueryLod(gsampler2DDArray sampler, vec2  P)
  │                 ║  vec2 textureQueryLod(gsamplerCubeArray sampler, vec3  P)
  │                 ║  vec2 textureQueryLod(gsampler1DShadow sampler, float P)
  │                 ║  vec2 textureQueryLod(gsampler2DShadow sampler, vec2  P)
  │                 ║  vec2 textureQueryLod(gsamplerCubeShadow sampler, vec3  P)
  │                 ║  vec2 textureQueryLod(gsampler1DArrayShadow sampler, float P)
  │                 ║  vec2 textureQueryLod(gsampler2DArrayShadow sampler, vec2  P)
  │                 ║  vec2 textureQueryLod(gsamplerCubeArrayShadow sampler, vec3  P)¶
  ├6║textureSamples║return the number of samples of a texture
  │                ║  int textureSamples(gsampler2DMS sampler)
  │                ║  int textureSamples(gsampler2DMSArray sampler)¶
  ├6║textureSize║retrieve the dimensions of a level of a texture
  │             ║  int   textureSize(gsampler1D sampler, int lod)
  │             ║  ivec2 textureSize(gsampler2D sampler, int lod)
  │             ║  ivec3 textureSize(gsampler3D sampler, int lod)
  │             ║  ivec2 textureSize(gsamplerCube sampler, int lod)
  │             ║  int   textureSize(sampler1DShadow sampler, int lod)
  │             ║  ivec2 textureSize(sampler2DShadow sampler, int lod)
  │             ║  ivec2 textureSize(samplerCubeShadow sampler, int lod)
  │             ║  ivec3 textureSize(samplerCubeArray sampler, int lod)
  │             ║  ivec3 textureSize(samplerCubeArrayShadow sampler, int lod)
  │             ║  ivec2 textureSize(gsamplerRect sampler)
  │             ║  ivec2 textureSize(gsamplerRectShadow sampler)
  │             ║  ivec2 textureSize(gsampler1DArray sampler, int lod)
  │             ║  ivec3 textureSize(gsampler2DArray sampler, int lod)
  │             ║  ivec2 textureSize(sampler1DArrayShadow sampler, int lod)
  │             ║  ivec3 textureSize(sampler2DArrayShadow sampler, int lod)
  │             ║  int   textureSize(gsamplerBuffer sampler)
  │             ║  ivec2 textureSize(gsampler2DMS sampler)
  │             ║  ivec3 textureSize(gsampler2DMSArray sampler)¶
  ├6║transpose║calculate the transpose of a matrix
  │           ║  mat2    transpose(mat2    m)
  │           ║  mat3    transpose(mat3    m)
  │           ║  mat4    transpose(mat4    m)
  │           ║  mat2x3  transpose(mat3x2  m)
  │           ║  mat2x4  transpose(mat4x2  m)
  │           ║  mat3x2  transpose(mat2x3  m)
  │           ║  mat3x4  transpose(mat4x3  m)
  │           ║  mat4x2  transpose(mat2x4  m)
  │           ║  mat4x3  transpose(mat3x4  m)
  │           ║  dmat2   transpose(dmat2   m)
  │           ║  dmat3   transpose(dmat3   m)
  │           ║  dmat4   transpose(dmat4   m)
  │           ║  dmat2x3 transpose(dmat3x2 m)
  │           ║  dmat2x4 transpose(dmat4x2 m)
  │           ║  dmat3x2 transpose(dmat2x3 m)
  │           ║  dmat3x4 transpose(dmat4x3 m)
  │           ║  dmat4x2 transpose(dmat2x4 m)
  │           ║  dmat4x3 transpose(dmat3x4 m)¶
  ├6║trunc║find the nearest integer less
  │       ║than or equal to the parameter
  │       ║  genType  trunc(genType  x)
  │       ║  genDType trunc(genDType x)¶
  ├6║uaddCarry║Add unsigned integers and generate carry. The
  │           ║carry result is the sum of x and y modulo 2^32.
  │           ║  genUType uaddCarry(genUType x, genUType y, out genUType carry)¶
  ├6║uintBitsToFloat║produce a floating point using an
  │                 ║encoding supplied as an integer
  │                 ║  genType uintBitsToFloat(genUType x)¶
  ├6║umulExtended║perform a 32- by 32-bit multiply to produce a 64-bit result
  │              ║  void umulExtended(genIType x, genIType y, out genIType msb, out genIType lsb)¶
  ├6║unpackDouble2x32║produce two unsigned integers containing the bit
  │                  ║encoding of a double precision floating point value
  │                  ║  uvec2 unpackDouble2x32(double d)¶
  ├6║unpackHalf2x16║convert two 16-bit floating-point values
  │                ║packed into a single 32-bit integer into a
  │                ║vector of two 32-bit floating-point quantities
  │                ║  vec2 unpackHalf2x16(uint v)¶
  ├6║unpackSnorm2x16║unpack floating-point values from an unsigned integer
  │                 ║  vec2 unpackUnorm2x16(uint p)¶
  ├6║unpackSnorm4x8║unpack floating-point values from an unsigned integer
  │                ║  vec2 unpackSnorm4x8(uint p)¶
  ├6║unpackUnorm2x16║unpack floating-point values from an unsigned integer
  │                 ║  vec2 unpackUnorm2x16(uint p)¶
  ├6║unpackUnorm4x8║unpack floating-point values from an unsigned integer
  │                ║  vec2 unpackUnorm4x8(uint p)¶
  ├6║usubBorrow║subtract unsigned integers and generate borrow
  │            ║  genUType usubBorrow(genUType x, genUType y, out genUType borrow)¶
  ├┬(?<=layout\s*\()(?:[^()]|(?<open>\()|(?<-open>\)))+(?(open)(?!))(?=\)\s+in)
  │├7║location║Assigns the stream to the specified unit.¶
  │├7║component║Used in combination with the location
  │            ║qualifier to address specific vec-
  │            ║components of the input stream.¶
  ├┬(?<=layout\s*\()(?:[^()]|(?<open>\()|(?<-open>\)))+(?(open)(?!))(?=\)\s+out)
  │├7║location║Assigns the stream to the specified unit.¶
  │├7║xfb_buffer║Specifies the transform feedback output buffer.¶
  │├7║xfb_offset║Specifies the first position of the transform
  ││            ║feedback output buffer to be written to.¶
  │├7║xfb_stride║Specifies the stride between transform feedback buffer outputs.¶
  │├7║component║Used in combination with the location
  │            ║qualifier to address specific vec-
  │            ║components of the output stream.¶
  ├┬(?<=layout\s*\()(?:[^()]|(?<open>\()|(?<-open>\)))+(?(open)(?!))(?=\)\s+uniform)
   ├7║r8¶
   ├7║r8i¶
   ├7║r8ui¶
   ├7║r16¶
   ├7║r16i¶
   ├7║r16ui¶
   ├7║r16f¶
   ├7║r32i¶
   ├7║r32ui¶
   ├7║r32f¶
   ├7║rg8¶
   ├7║rg8i¶
   ├7║rg8ui¶
   ├7║rg16¶
   ├7║rg16i¶
   ├7║rg16ui¶
   ├7║rg16f¶
   ├7║rg32i¶
   ├7║rg32ui¶
   ├7║rg32f¶
   ├7║rgb8¶
   ├7║rgb8i¶
   ├7║rgb8ui¶
   ├7║rgb16¶
   ├7║rgb16i¶
   ├7║rgb16ui¶
   ├7║rgb16f¶
   ├7║rgb32i¶
   ├7║rgb32ui¶
   ├7║rgb32f¶
   ├7║rgba8¶
   ├7║rgba8i¶
   ├7║rgba8ui¶
   ├7║rgba16¶
   ├7║rgba16i¶
   ├7║rgba16ui¶
   ├7║rgba16f¶
   ├7║rgba32i¶
   ├7║rgba32ui¶
   ├7║rgba32f¶
   ├7║std140║Force variables to be vec4 aligned.¶
   ├7║binding║The binding unit of the shader resource.¶
   ├7║offset║Atomic counters also have an optional offset parameter.
            ║The offset is the byte offset from the beginning of the
            ║range bound to the target to the location where this
            ║variable gets its 32-bits of storage.¶