buffer|buffer <name>
buffer.size|size <bytes>
buffer.txt|txt <text_name>
buffer.usage|usage <usage_hint>
buffer.usage.dynamicCopy
buffer.usage.dynamicDraw
buffer.usage.dynamicRead
buffer.usage.staticCopy
buffer.usage.staticDraw
buffer.usage.staticRead
buffer.usage.streamCopy
buffer.usage.streamDraw
buffer.usage.streamRead
buffer.xml|xml <path> <node>
csharp|csharp <name>
csharp.file|file <path> [path] [...]
fragoutput|fragoutput <name>
fragoutput.color|color <image_name>
fragoutput.depth|depth <image_name>
fragoutput.height|height <pixels>
fragoutput.width|width <pixels>
image|image <name>
image.depth|depth <layers>
image.file|file <path> [path] [...]
image.format|format <pixel_format>
image.format.depth
image.format.depth16
image.format.depth24
image.format.depth24stencil8
image.format.depth32
image.format.depth32f
image.format.depth32fstencil8
image.format.depthstencil
image.format.r8
image.format.r8i
image.format.r8ui
image.format.r16
image.format.r16i
image.format.r16ui
image.format.r16f
image.format.r32i
image.format.r32ui
image.format.r32f
image.format.rg8
image.format.rg8i
image.format.rg8ui
image.format.rg16
image.format.rg16i
image.format.rg16ui
image.format.rg16f
image.format.rg32i
image.format.rg32ui
image.format.rg32f
image.format.rgb8
image.format.rgb8i
image.format.rgb8ui
image.format.rgb16
image.format.rgb16i
image.format.rgb16ui
image.format.rgb16f
image.format.rgb32i
image.format.rgb32ui
image.format.rgb32f
image.format.rgba8
image.format.rgba8i
image.format.rgba8ui
image.format.rgba16
image.format.rgba16i
image.format.rgba16ui
image.format.rgba16f
image.format.rgba32i
image.format.rgba32ui
image.format.rgba32f
image.height|height <pixels>
image.length|length <layers>
image.type|type <texture_type>
image.type.texture1D|1D texture
image.type.texture2D|2D texture
image.type.texture3D|3D texture/volume texture
image.type.texture1DArray|1D texture array
image.type.texture2DArray|2D texture array
image.width|width <pixels>
instance|instance <name>
instance.class|class <csharp_name> <c#_class>
instance.name|name <new_name>
pass|pass <name>
pass.comp|comp <shader_name>
pass.compute|Dispatch compute shader call.
   compute <num_group_x> <num_group_y> [num_group_z]
   compute <callbuffer_name>
pass.draw|Draw vertex based (possibly indexed) geometry.
 
   draw <vertinput_name> <primitive_type> <base_vertex> <vertex_count>
        [base_instance] [instance_count]
   draw <vertinput_name> <indexbuffer_name> <index_type> <primitive_type>
        <base_vertex> <base_index> <index_count> [base_instance] [instance_count]
   draw <vertinput_name> <callbuffer_name> <primitive_type>
        [buffer_offset] [draw_count] [stride]
   draw <vertinput_name> <indexbuffer_name> <index_type> <callbuffer_name>
        <primitive_type> [buffer_offset]  [draw_count] [stride]
   draw <vertoutput_name> <primitive_type> [vertoutput_stream] [instance_count]
   
 primitive_type -- 
     points, lines, lineLoop, lineStrip, triangles, triangleStrip, triangleFan, patch,
     linesAdjacency, lineStripAdjacency, trianglesAdjacency, triangleStripAdjacency
 index_type -- 
     ubyte, ushort, uint
pass.draw.lineLoop
pass.draw.lines
pass.draw.linesAdjacency
pass.draw.lineStrip
pass.draw.lineStripAdjacency
pass.draw.patch
pass.draw.points
pass.draw.triangleFan
pass.draw.triangles
pass.draw.trianglesAdjacency
pass.draw.triangleStrip
pass.draw.triangleStripAdjacency
pass.draw.ubyte|index buffer type is unsigned byte
pass.draw.uint|index buffer type is unsigned integer
pass.draw.ushort|index buffer type is unsigned short
pass.fragout|fragout <fragoutput_name>
pass.vertout|vertout <vertoutput_name> <output_primitive_type> [write_mode] <output_varying_name>
 
     The optional argument [write_mode] can be 'gl_SeparateAttribs' (write every
     <output_varying_name> to a new buffer) or the default 'gl_InterleavedAttribs'
     (output varyings for different buffers need to be separated by 'gl_NextBuffer')
pass.vertout.lines
pass.vertout.points
pass.vertout.triangles
pass.eval|eval <shader_name>
pass.exec|exec <instance_name>
pass.frag|frag <shader_name>
pass.geom|geom <shader_name>
pass.tess|tess <shader_name>
pass.tex|tex <texture_name> <unit>
pass.vert|vert <shader_name>
sampler|sampler <name>
sampler.magfilter|magfilter <filter_type>
sampler.magfilter.linear
sampler.magfilter.nearest
sampler.minfilter|minfilter <filter_type>
sampler.minfilter.linear
sampler.minfilter.nearest
sampler.minfilter.LinearMipmapLinear
sampler.minfilter.LinearMipmapNearest
sampler.minfilter.NearestMipmapLinear
sampler.minfilter.NearestMipmapNearest
sampler.wrap|wrap <wrap_type>
sampler.wrap.ClampToBorder
sampler.wrap.ClampToEdge
sampler.wrap.MirroredRepeat
sampler.wrap.Repeat
shader|shader <shader_type> <name>
shader,comp|comp
   in  uvec3 gl_NumWorkGroups
   in  uvec3 gl_WorkGroupSize
   in  uvec3 gl_WorkGroupID
   in  uvec3 gl_LocalInvocationID
   in  uvec3 gl_GlobalInvocationID
   in  uint  gl_LocalInvocationIndex
shader,eval|eval
   in  vec3  gl_TessCoord
   in  int   gl_PatchVerticesIn
   in  int   gl_PrimitiveID
   in  float gl_TessLevelOuter[4]
   in  float gl_TessLevelInner[2]
   in  vec4  gl_in[].gl_Position
   in  float gl_in[].gl_PointSize
   in  float gl_in[].gl_ClipDistance[]
   out vec4  gl_Position
   out float gl_PointSize
   out float gl_ClipDistance[]
shader,frag|frag
   in  vec4  gl_FragCoord
   in  bool  gl_FrontFacing
   in  vec2  gl_PointCoord
   in  int   gl_SampleID
   in  vec2  gl_SamplePosition
   in  int   gl_SampleMaskIn[]
   in  float gl_ClipDistance[]
   in  int   gl_PrimitiveID
   in  int   gl_Layer
   in  int   gl_ViewportIndex
   out float gl_FragDepth
   out int   gl_SampleMask[]
shader,geom|geom
   in  int   gl_PrimitiveIDIn
   in  int   gl_InvocationID
   in  vec4  gl_in[].gl_Position
   in  float gl_in[].gl_PointSize
   in  float gl_in[].gl_ClipDistance[]
   out int   gl_PrimitiveID
   out int   gl_Layer
   out int   gl_ViewportIndex
   out vec4  gl_Position
   out float gl_PointSize
   out float gl_ClipDistance[]
shader,tess|tess
   in  int   gl_PatchVerticesIn
   in  int   gl_PrimitiveID
   in  int   gl_InvocationID
   in  vec4  gl_in[].gl_Position
   in  float gl_in[].gl_PointSize
   in  float gl_in[].gl_ClipDistance[]
   out float gl_TessLevelOuter[4]
   out float gl_TessLevelInner[4]
   out vec4  gl_out[].gl_Position
   out float gl_out[].gl_PointSize
   out float gl_out[].gl_ClipDistance[]
shader,vert|vert
   in  int   gl_VertexID
   in  int   gl_InstanceID
   out vec4  gl_Position
   out float gl_PointSize
   out float gl_ClipDistance[]
shader.abs|abs -- return the absolute value of the parameter
   genType  abs(genType  x)
   genIType abs(genIType x)
   genDType abs(genDType x)
shader.acos|acos -- return the arccosine of the parameter
   genType acos(genType x)
shader.acosh|acosh -- return the arc hyperbolic cosine of the parameter
   genType acosh(genType x)
shader.all|all -- check whether all elements of a boolean vector are true
   bool all(bvec x)
shader.any|any -- check whether any element of a boolean vector is true
   bool any(bvec x)
shader.asin|asin -- return the arcsine of the parameter
   genType asin(genType x)
shader.asinh|asinh -- return the arc hyperbolic sine of the parameter
   genType asinh(genType x)
shader.atan|atan -- return the arc-tangent of the parameters
   genType atan(genType x)
shader.atanh|atanh -- return the arc hyperbolic tangent of the parameter
   genType atanh(genType x)
shader:atomic_uint
shader.atomicAdd|atomicAdd -- perform an atomic addition to a variable
   int  atomicAdd(inout int  mem, int  data)
   uint atomicAdd(inout uint mem, uint data)
shader.atomicAnd|atomicAnd -- perform an atomic logical AND operation to a variable
   int  atomicAdd(inout int  mem, int  data)
   uint atomicAdd(inout uint mem, uint data)
shader.atomicCompSwap|atomicCompSwap -- perform an atomic compare-exchange operation to a variable
   int  atomicCompSwap(inout int  mem, uint compare, uint data)
   uint atomicCompSwap(inout uint mem, uint compare, uint data)
shader.atomicCounter|atomicCounter -- return the current value of an atomic counter
   uint atomicCounter(atomic_uint c)
shader.atomicCounterDecrement|atomicCounterDecrement -- atomically decrement a counter and return the prior value
   uint atomicCounterDecrement(atomic_uint c)
shader.atomicCounterIncrement|atomicCounterIncrement -- atomically increment a counter and return the prior value
   uint atomicCounterIncrement(atomic_uint c)
shader.atomicExchange|atomicExchange -- perform an atomic exchange operation to a variable
   int  atomicExchange(inout int  mem, int  data)
   uint atomicExchange(inout uint mem, uint data)
shader.atomicMax|atomicMax -- perform an atomic max operation to a variable
   int  atomicMax(inout int  mem, int  data)
   uint atomicMax(inout uint mem, uint data)
shader.atomicMin|atomicMin -- perform an atomic min operation to a variable
   int  atomicMin(inout int  mem, int  data)
   uint atomicMin(inout uint mem, uint data)
shader.atomicOr|atomicOr -- perform an atomic logical OR operation to a variable
   int  atomicOr(inout int  mem, int  data)
   uint atomicOr(inout uint mem, uint data)
shader.atomicXor|atomicXor -- perform an atomic logical exclusive OR operation to a variable
   int  atomicXor(inout int  mem, int  data)
   uint atomicXor(inout uint mem, uint data)
shader.barrier|barrier -- synchronize execution of multiple shader invocations
   void barrier(void)
shader.bitCount|bitCount -- counts the number of 1 bits in an integer
   genIType bitCount(genIType value)
   genIType bitCount(genUType value)
shader.bitfieldExtract|bitfieldExtract -- extract a range of bits from an integer
   genIType bitfieldExtract(genIType value, int offset, int bits)
   genUType bitfieldExtract(genUType value, int offset, int bits)
shader.bitfieldInsert|bitfieldInsert -- insert a range of bits into an integer
   genIType bitfieldInsert(genIType base, genIType insert, int offset, int bits)
   genUType bitfieldInsert(genUType base, genUType insert, int offset, int bits)
shader.bitfieldReverse|bitfieldReverse -- reverse the order of bits in an integer
   genIType bitfieldReverse(genIType value)
   genUType bitfieldReverse(genUType value)
shader:bvec2
shader:bvec3
shader:bvec4
shader.ceil|ceil -- find the nearest integer that is greater than or equal to the parameter
   genType  ceil(genType  x)
   genDType ceil(genDType x)
shader:centroid|During multisampling, if centroid​ is not present, then the written value
 can be interpolated to an arbitrary position within the pixel. This may
 be the pixel's center, one of the sample locations within the pixel, or
 an arbitrary location. Most importantly of all, this sample may lie
 outside of the actual primitive being rendered, since a primitive can
 cover only part of a pixel's area. If the implementation computes the
 sample based on the center of the pixel, and the primitive doesn't still
 actually cover the pixel's center (remember: in multisampling, this can
 produce a non-zero number of samples), then the interpolated value will
 be outside of the primitive's borders.
   The centroid​ qualifier is used to prevent this; the interpolation point
 must fall within both the pixel's area and the primitive's area. This is
 useful for parameters or computations that would have undefined values if
 they fell outside of the primitive's area. A square root is only defined
 for positive numbers, so if you are taking the square root of an
 interpolated value, you may need to use centroid​ interpolation.
   You should only use centroid​ if there is a real problem like this. In
 many cases interpolating without centroid doesn't pose a problem. 
shader.clamp|clamp -- constrain a value to lie between two further values
   genType  clamp(genType  x, genType minVal, genType maxVal)
   genType  clamp(genType  x, float minVal, float maxVal)
   genDType clamp(genDType x, genDType minVal, genDType maxVal)
   genDType clamp(genDType x, double minVal, double maxVal)
   genIType clamp(genIType x, genIType minVal, genIType maxVal)
   genIType clamp(genIType x, int minVal, int maxVal)
   genUType clamp(genUType x, genUType minVal, genUType maxVal)
   genUType clamp(genUType x, uint minVal, uint maxVal)
shader:const
shader.cos|cos -- return the cosine of the parameter
   genType cos(genType angle)
shader.cosh|cosh -- return the hyperbolic cosine of the parameter
   genType cosh(genType x)
shader.cross|cross -- calculate the cross product of two vectors
   vec3  cross(vec3  x, vec3  y)
   dvec3 cross(dvec3 x, dvec3 y)
shader.degrees|degrees -- convert a quantity in radians to degrees
   genType degrees(genType radians)
shader.determinant|determinant -- calculate the determinant of a matrix
   float determinant(mat2 m)
   float determinant(mat3 m)
   float determinant(mat4 m)
   double determinant(dmat2 m)
   double determinant(dmat3 m)
   double determinant(dmat4 m)
shader:discard
shader.dFdx|dFdx -- return the partial derivative of an argument with respect to x
   genType dFdx(genType p)
shader.dFdxCoarse|dFdxCoarse -- return the partial derivative of an argument with respect to x
   genType dFdxCoarse(genType p)
shader.dFdxFine|dFdxFine -- return the partial derivative of an argument with respect to x
   genType dFdxFine(genType p)
shader.dFdy|dFdy -- return the partial derivative of an argument with respect to y
   genType dFdy(genType p)
shader.dFdyCoarse|dFdyCoarse -- return the partial derivative of an argument with respect to y
   genType dFdyCoarse(genType p)
shader.dFdyFine|dFdyFine -- return the partial derivative of an argument with respect to y
   genType dFdyFine(genType p)
shader.distance|distance -- calculate the distance between two points
   float distance(genType p0, genType p1)
   double distance(genDType p0, genDType p1)
shader.dot|dot -- calculate the dot product of two vectors
   float dot(genType x, genType y)
   double dot(genDType x, genDType y)
shader:dmat2
shader:dmat2x2
shader:dmat2x3
shader:dmat2x4
shader:dmat3
shader:dmat3x2
shader:dmat3x3
shader:dmat3x4
shader:dmat4
shader:dmat4x2
shader:dmat4x3
shader:dmat4x4
shader:dvec2
shader:dvec3
shader:dvec4
shader:else
shader.EmitStreamVertex|EmitStreamVertex -- emit a vertex to a specified stream
   void EmitStreamVertex(int stream)
shader.EmitVertex|EmitVertex -- emit a vertex to the first vertex stream
   void EmitVertex(void)
shader.EndPrimitive|EndPrimitive -- complete the current output primitive on the first vertex stream
   void EndPrimitive(void)
shader.EndStreamPrimitive|EndStreamPrimitive -- complete the current output primitive on a specified stream
   void EndStreamPrimitive(int stream)
shader.equal|equal -- perform a component-wise equal-to comparison of two vectors
   bvec equal(vec x, vec y)
   bvec equal(ivec x, ivec y)
   bvec equal(uvec x, uvec y)
shader.exp|exp -- return the natural exponentiation of the parameter
   genType exp(genType x)
shader.exp2|exp2 -- return 2 raised to the power of the parameter
   genType exp2(genType x)
shader.faceforward|faceforward -- return a vector pointing in the same direction as another
   genType  faceforward(genType  N, genType  I, genType  Nref)
   genDType faceforward(genDType N, genDType I, genDType Nref)
shader.findLSB|findLSB -- find the index of the least significant bit set to 1 in an integer
   genIType findLSB(genIType value)
   genIType findLSB(genUType value)
shader.findMSB|findMSB -- find the index of the most significant bit set to 1 in an integer
   genIType findMSB(genIType value)
   genIType findMSB(genUType value)
shader.flat|The in/out value will not be interpolated. The
 value given to the fragment shader is the value
 from the Provoking Vertex for that primitive.
shader:float
shader.floor|floor -- find the nearest integer less than or equal to the parameter
   genType  floor(genType  x)
   genDType floor(genDType x)
shader.fma|fma -- perform a fused multiply-add operation
   genType  fma(genType  a, genType  b, genType  c)
   genDType fma(genDType a, genDType b, genDType c)
shader:for
shader.fract|fract -- compute the fractional part of the argument
   genType  fract(genType  x)
   genDType fract(genDType x)
shader.frexp|frexp -- split a floating point number
   genType  frexp(genType  x, out genIType exp)
   genDType frexp(genDType x, out genIType exp)
shader.fwidth|fwidth -- return the sum of the absolute value of derivatives in x and y
   genType fwidth(genType p)
shader.fwidthCoarse|fwidthCoarse -- return the sum of the absolute value of derivatives in x and y
   genType fwidthCoarse(genType p)
shader.fwidthFine|fwidthFine -- return the sum of the absolute value of derivatives in x and y
   genType fwidthFine(genType p)
shader:gl_ClipDistance|gl_ClipDistance -- provides a forward-compatible mechanism for vertex clipping
shader:gl_CullDistance|gl_CullDistance -- provides a mechanism for controlling user culling
shader:gl_DepthRange|gl_DepthRange -- provides access to the
                 glDepthRange​ near and far values
   gl_DepthRange.far  -- glDepthRange​ far value
   gl_DepthRange.near -- glDepthRange​ near value
   gl_DepthRange.diff -- diff = far - near
shader:gl_FragCoord|gl_FragCoord -- contains the window-relative coordinates of the current fragment
shader:gl_FragDepth|gl_FragDepth -- establishes a depth value for the current fragment
shader:gl_FrontFacing|gl_FrontFacing -- indicates whether a primitive is front or back facing
shader:gl_GlobalInvocationID|gl_GlobalInvocationID -- contains the global index of work item
                         currently being operated on by a compute shader
shader:gl_HelperInvocation|gl_HelperInvocation -- indicates whether a fragment shader invocation is a helper invocation
shader:gl_InstanceID|gl_InstanceID -- contains the index of the current primitive in an instanced draw command
shader:gl_InvocationID|gl_InvocationID -- contains the invocation index of the current shader
shader:gl_Layer|gl_Layer -- contains the selected layer of a multi-layer framebuffer attachment
shader:gl_LocalInvocationID|gl_LocalInvocationID -- contains the index of work item currently
                        being operated on by a compute shader
shader:gl_LocalInvocationIndex|gl_LocalInvocationIndex -- contains the local linear indexof work item
                           currently being operated on by a compute shader
shader:gl_MaxPatchVertices|gl_MaxPatchVertices -- the maximum number of patch vertices supported
shader:gl_NumSamples|gl_NumSamples​ -- is the number of samples in the current Framebuffer
shader:gl_NumWorkGroups|gl_NumWorkGroups -- contains the number of workgroups that
                    have been dispatched to a compute shader
shader:gl_PatchVerticesIn|gl_PatchVerticesIn -- contains the number of vertices in the current patch
shader:gl_PointCoord|gl_PointCoord -- contains the coordinate of a fragment within a point
shader:gl_PointSize|gl_PointSize -- contains size of rasterized points, in pixels
shader:gl_Position|gl_Position -- contains the position of the current vertex
shader:gl_PrimitiveID|gl_PrimitiveID -- contains the index of the current primitive
shader:gl_PrimitiveIDIn|gl_PrimitiveIDIn -- contains the index of the current primitive
shader:gl_SampleID|gl_SampleID -- contains the index of the sample currently being processed
shader:gl_SampleMask|gl_SampleMask -- specifies the sample coverage mask for the current fragment
shader:gl_SampleMaskIn|gl_SampleMaskIn -- contains the computed sample coverage mask for the current fragment
shader:gl_SamplePosition|gl_SamplePosition -- contains the location of the current sample within the current fragment
shader:gl_TessLevelInner|gl_TessLevelInner -- contains the inner tessellation levels for the current patch
shader:gl_TessLevelOuter|gl_TessLevelOuter -- contains the outer tessellation levels for the current patch
shader:gl_VertexID|gl_VertexID -- contains the index of the current vertex
shader:gl_ViewportIndex|gl_ViewportIndex -- contains the index of the viewport to be used
                    in viewport transformation and scissoring
shader:gl_WorkGroupID|gl_WorkGroupID -- contains the index of the workgroup currently
                  being operated on by a compute shader
shader:gl_WorkGroupSize|gl_WorkGroupSize -- contains the size of the workgroup operated on by a compute shader
shader:gl_in|gl_in -- input varying structure for tess. control,
         tess. evaluation and geometry shader
shader:gl_out|gl_in -- output varying structure for tess. control,
         tess. evaluation and geometry shader
shader.greaterThan|greaterThan -- perform a component-wise greater-than
               comparison of two vectors
   bvec greaterThan(vec x, vec y)
   bvec greaterThan(ivec x, ivec y)
   bvec greaterThan(uvec x, uvec y)
shader.greaterThanEqual|greaterThanEqual -- perform a component-wise greater-than-or-equal
                    comparison of two vectors
   bvec greaterThanEqual(vec x, vec y)
   bvec greaterThanEqual(ivec x, ivec y)
   bvec greaterThanEqual(uvec x, uvec y)
shader.groupMemoryBarrier|groupMemoryBarrier -- controls the ordering of memory transaction issued
                      shader invocation relative to a work group
   void groupMemoryBarrier(void)
shader:if
shader:image1D|1D image binding unit
shader:image1DArray|1D image array binding unit
shader:image2D|2D image binding unit
shader:image2DArray|2D image array binding unit
shader:image2DMS|2D multi-sample image binding unit
shader:image2DMSArray|2D multi-sample image array binding unit
shader:image2DRect|2D rectangular image array binding unit
shader:image3D|3D image array binding unit
shader:imageBuffer|buffer image binding unit
shader:imageCube|cube map image binding unit
shader:imageCubeArray|cube map image array binding unit
shader.imageAtomicAdd|imageAtomicAdd -- atomically add a value to an existing value in memory
                  and return the original value
   uint imageAtomicAdd(gimage1D image, int   P, uint data)
   uint imageAtomicAdd(gimage2D image, ivec2 P, uint data)
   uint imageAtomicAdd(gimage3D image, ivec3 P, uint data)
   uint imageAtomicAdd(gimage2DRect image, ivec2 P, uint data)
   uint imageAtomicAdd(gimageCube   image, ivec3 P, uint data)
   uint imageAtomicAdd(gbufferImage image, int   P, uint data)
   uint imageAtomicAdd(gimage1DArray   image, ivec2 P, uint data)
   uint imageAtomicAdd(gimage2DArray   image, ivec3 P, uint data)
   uint imageAtomicAdd(gimageCubeArray image, ivec3 P, uint data)
   uint imageAtomicAdd(gimage2DMS image, ivec2 P, int sample, uint data)
   uint imageAtomicAdd(gimage2DMSArray image, ivec3 P, int sample, uint data)
   int  imageAtomicAdd(gimage1D image, int   P, int data)
   int  imageAtomicAdd(gimage2D image, ivec2 P, int data)
   int  imageAtomicAdd(gimage3D image, ivec3 P, int data)
   int  imageAtomicAdd(gimage2DRect image, ivec2 P, int data)
   int  imageAtomicAdd(gimageCube   image, ivec3 P, int data)
   int  imageAtomicAdd(gbufferImage image, int   P, int data)
   int  imageAtomicAdd(gimage1DArray   image, ivec2 P, int data)
   int  imageAtomicAdd(gimage2DArray   image, ivec3 P, int data)
   int  imageAtomicAdd(gimageCubeArray image, ivec3 P, int data)
   int  imageAtomicAdd(gimage2DMS image, ivec2 P, int sample, int data)
   int  imageAtomicAdd(gimage2DMSArray image, ivec3 P, int sample, int data)
shader.imageAtomicAnd|imageAtomicAnd -- atomically compute the logical AND of a value with an existing
                 value in memory, store that value and return the original value
   uint imageAtomicAnd(gimage1D image, int   P, uint data)
   uint imageAtomicAnd(gimage2D image, ivec2 P, uint data)
   uint imageAtomicAnd(gimage3D image, ivec3 P, uint data)
   uint imageAtomicAnd(gimage2DRect image, ivec2 P, uint data)
   uint imageAtomicAnd(gimageCube   image, ivec3 P, uint data)
   uint imageAtomicAnd(gbufferImage image, int   P, uint data)
   uint imageAtomicAnd(gimage1DArray   image, ivec2 P, uint data)
   uint imageAtomicAnd(gimage2DArray   image, ivec3 P, uint data)
   uint imageAtomicAnd(gimageCubeArray image, ivec3 P, uint data)
   uint imageAtomicAnd(gimage2DMS image, ivec2 P, int sample, uint data)
   uint imageAtomicAnd(gimage2DMSArray image, ivec3 P, int sample, uint data)
   int  imageAtomicAnd(gimage1D image, int   P, int data)
   int  imageAtomicAnd(gimage2D image, ivec2 P, int data)
   int  imageAtomicAnd(gimage3D image, ivec3 P, int data)
   int  imageAtomicAnd(gimage2DRect image, ivec2 P, int data)
   int  imageAtomicAnd(gimageCube   image, ivec3 P, int data)
   int  imageAtomicAnd(gbufferImage image, int   P, int data)
   int  imageAtomicAnd(gimage1DArray   image, ivec2 P, int data)
   int  imageAtomicAnd(gimage2DArray   image, ivec3 P, int data)
   int  imageAtomicAnd(gimageCubeArray image, ivec3 P, int data)
   int  imageAtomicAnd(gimage2DMS image, ivec2 P, int sample, int data)
   int  imageAtomicAnd(gimage2DMSArray image, ivec3 P, int sample, int data)
shader.imageAtomicCompSwap|imageAtomicCompSwap -- atomically compares supplied data with that in memory and
                      conditionally stores it to memory
   uint imageAtomicCompSwap(gimage1D image, int   P, uint compare, uint data)
   uint imageAtomicCompSwap(gimage2D image, ivec2 P, uint compare, uint data)
   uint imageAtomicCompSwap(gimage3D image, ivec3 P, uint compare, uint data)
   uint imageAtomicCompSwap(gimage2DRect image, ivec2 P, uint compare, uint data)
   uint imageAtomicCompSwap(gimageCube   image, ivec3 P, uint compare, uint data)
   uint imageAtomicCompSwap(gbufferImage image, int   P, uint compare, uint data)
   uint imageAtomicCompSwap(gimage1DArray   image, ivec2 P, uint compare, uint data)
   uint imageAtomicCompSwap(gimage2DArray   image, ivec3 P, uint compare, uint data)
   uint imageAtomicCompSwap(gimageCubeArray image, ivec3 P, uint compare, uint data)
   uint imageAtomicCompSwap(gimage2DMS image, ivec2 P, int sample, uint compare, uint data)
   uint imageAtomicCompSwap(gimage2DMSArray image, ivec3 P, int sample, uint compare, uint data)
   int  imageAtomicCompSwap(gimage1D image, int   P, int compare, int data)
   int  imageAtomicCompSwap(gimage2D image, ivec2 P, int compare, int data)
   int  imageAtomicCompSwap(gimage3D image, ivec3 P, int compare, int data)
   int  imageAtomicCompSwap(gimage2DRect image, ivec2 P, int compare, int data)
   int  imageAtomicCompSwap(gimageCube   image, ivec3 P, int compare, int data)
   int  imageAtomicCompSwap(gbufferImage image, int   P, int compare, int data)
   int  imageAtomicCompSwap(gimage1DArray   image, ivec2 P, int compare, int data)
   int  imageAtomicCompSwap(gimage2DArray   image, ivec3 P, int compare, int data)
   int  imageAtomicCompSwap(gimageCubeArray image, ivec3 P, int compare, int data)
   int  imageAtomicCompSwap(gimage2DMS image, ivec2 P, int sample, int compare, int data)
   int  imageAtomicCompSwap(gimage2DMSArray image, ivec3 P, int sample, int compare, int data)
shader.imageAtomicExchange|imageAtomicExchange -- atomically store supplied data into memory and
                      return the original value from memory
   uint imageAtomicExchange(gimage1D image, int P, uint data)
   uint imageAtomicExchange(gimage2D image, ivec2 P, uint data)
   uint imageAtomicExchange(gimage3D image, ivec3 P, uint data)
   uint imageAtomicExchange(gimage2DRect image, ivec2 P, uint data)
   uint imageAtomicExchange(gimageCube image, ivec3 P, uint data)
   uint imageAtomicExchange(gbufferImage image, int P, uint data)
   uint imageAtomicExchange(gimage1DArray image, ivec2 P, uint data)
   uint imageAtomicExchange(gimage2DArray image, ivec3 P, uint data)
   uint imageAtomicExchange(gimageCubeArray image, ivec3 P, uint data)
   uint imageAtomicExchange(gimage2DMS image, ivec2 P, int sample, uint data)
   uint imageAtomicExchange(gimage2DMSArray image, ivec3 P, int sample, uint data)
   int  imageAtomicExchange(gimage1D image, int P, int data)
   int  imageAtomicExchange(gimage2D image, ivec2 P, int data)
   int  imageAtomicExchange(gimage3D image, ivec3 P, int data)
   int  imageAtomicExchange(gimage2DRect image, ivec2 P, int data)
   int  imageAtomicExchange(gimageCube image, ivec3 P, int data)
   int  imageAtomicExchange(gbufferImage image, int P, int data)
   int  imageAtomicExchange(gimage1DArray image, ivec2 P, int data)
   int  imageAtomicExchange(gimage2DArray image, ivec3 P, int data)
   int  imageAtomicExchange(gimageCubeArray image, ivec3 P, int data)
   int  imageAtomicExchange(gimage2DMS image, ivec2 P, int sample, int data)
   int  imageAtomicExchange(gimage2DMSArray image, ivec3 P, int sample, int data)
   int  imageAtomicExchange(gimage1D image, int P, float data)
   int  imageAtomicExchange(gimage2D image, ivec2 P, float data)
   int  imageAtomicExchange(gimage3D image, ivec3 P, float data)
   int  imageAtomicExchange(gimage2DRect image, ivec2 P, float data)
   int  imageAtomicExchange(gimageCube image, ivec3 P, float data)
   int  imageAtomicExchange(gbufferImage image, int P, float data)
   int  imageAtomicExchange(gimage1DArray image, ivec2 P, float data)
   int  imageAtomicExchange(gimage2DArray image, ivec3 P, float data)
   int  imageAtomicExchange(gimageCubeArray image, ivec3 P, float data)
   int  imageAtomicExchange(gimage2DMS image, ivec2 P, int sample, float data)
   int  imageAtomicExchange(gimage2DMSArray image, ivec3 P, int sample, float data)
shader.imageAtomicMax|imageAtomicMax -- atomically compute the minimum of a value with an existing
                 value in memory, store that value and return the original value
   uint imageAtomicMax(gimage1D image, int   P, uint data)
   uint imageAtomicMax(gimage2D image, ivec2 P, uint data)
   uint imageAtomicMax(gimage3D image, ivec3 P, uint data)
   uint imageAtomicMax(gimage2DRect image, ivec2 P, uint data)
   uint imageAtomicMax(gimageCube   image, ivec3 P, uint data)
   uint imageAtomicMax(gbufferImage image, int   P, uint data)
   uint imageAtomicMax(gimage1DArray   image, ivec2 P, uint data)
   uint imageAtomicMax(gimage2DArray   image, ivec3 P, uint data)
   uint imageAtomicMax(gimageCubeArray image, ivec3 P, uint data)
   uint imageAtomicMax(gimage2DMS image, ivec2 P, int sample, uint data)
   uint imageAtomicMax(gimage2DMSArray image, ivec3 P, int sample, uint data)
   int  imageAtomicMax(gimage1D image, int   P, int data)
   int  imageAtomicMax(gimage2D image, ivec2 P, int data)
   int  imageAtomicMax(gimage3D image, ivec3 P, int data)
   int  imageAtomicMax(gimage2DRect image, ivec2 P, int data)
   int  imageAtomicMax(gimageCube   image, ivec3 P, int data)
   int  imageAtomicMax(gbufferImage image, int   P, int data)
   int  imageAtomicMax(gimage1DArray   image, ivec2 P, int data)
   int  imageAtomicMax(gimage2DArray   image, ivec3 P, int data)
   int  imageAtomicMax(gimageCubeArray image, ivec3 P, int data)
   int  imageAtomicMax(gimage2DMS image, ivec2 P, int sample, int data)
   int  imageAtomicMax(gimage2DMSArray image, ivec3 P, int sample, int data)
shader.imageAtomicMin|imageAtomicMin -- atomically compute the minimum of a value with an existing
                 value in memory, store that value and return the original value
   uint imageAtomicMin(gimage1D image, int   P, uint data)
   uint imageAtomicMin(gimage2D image, ivec2 P, uint data)
   uint imageAtomicMin(gimage3D image, ivec3 P, uint data)
   uint imageAtomicMin(gimage2DRect image, ivec2 P, uint data)
   uint imageAtomicMin(gimageCube   image, ivec3 P, uint data)
   uint imageAtomicMin(gbufferImage image, int   P, uint data)
   uint imageAtomicMin(gimage1DArray   image, ivec2 P, uint data)
   uint imageAtomicMin(gimage2DArray   image, ivec3 P, uint data)
   uint imageAtomicMin(gimageCubeArray image, ivec3 P, uint data)
   uint imageAtomicMin(gimage2DMS image, ivec2 P, int sample, uint data)
   uint imageAtomicMin(gimage2DMSArray image, ivec3 P, int sample, uint data)
   int  imageAtomicMin(gimage1D image, int   P, int data)
   int  imageAtomicMin(gimage2D image, ivec2 P, int data)
   int  imageAtomicMin(gimage3D image, ivec3 P, int data)
   int  imageAtomicMin(gimage2DRect image, ivec2 P, int data)
   int  imageAtomicMin(gimageCube   image, ivec3 P, int data)
   int  imageAtomicMin(gbufferImage image, int   P, int data)
   int  imageAtomicMin(gimage1DArray   image, ivec2 P, int data)
   int  imageAtomicMin(gimage2DArray   image, ivec3 P, int data)
   int  imageAtomicMin(gimageCubeArray image, ivec3 P, int data)
   int  imageAtomicMin(gimage2DMS image, ivec2 P, int sample, int data)
   int  imageAtomicMin(gimage2DMSArray image, ivec3 P, int sample, int data)
shader.imageAtomicOr|imageAtomicOr -- atomically compute the logical OR of a value with an existing
                value in memory, store that value and return the original value
   uint imageAtomicOr(gimage1D image, int   P, uint data)
   uint imageAtomicOr(gimage2D image, ivec2 P, uint data)
   uint imageAtomicOr(gimage3D image, ivec3 P, uint data)
   uint imageAtomicOr(gimage2DRect image, ivec2 P, uint data)
   uint imageAtomicOr(gimageCube   image, ivec3 P, uint data)
   uint imageAtomicOr(gbufferImage image, int   P, uint data)
   uint imageAtomicOr(gimage1DArray   image, ivec2 P, uint data)
   uint imageAtomicOr(gimage2DArray   image, ivec3 P, uint data)
   uint imageAtomicOr(gimageCubeArray image, ivec3 P, uint data)
   uint imageAtomicOr(gimage2DMS image, ivec2 P, int sample, uint data)
   uint imageAtomicOr(gimage2DMSArray image, ivec3 P, int sample, uint data)
   int  imageAtomicOr(gimage1D image, int   P, int data)
   int  imageAtomicOr(gimage2D image, ivec2 P, int data)
   int  imageAtomicOr(gimage3D image, ivec3 P, int data)
   int  imageAtomicOr(gimage2DRect image, ivec2 P, int data)
   int  imageAtomicOr(gimageCube   image, ivec3 P, int data)
   int  imageAtomicOr(gbufferImage image, int   P, int data)
   int  imageAtomicOr(gimage1DArray   image, ivec2 P, int data)
   int  imageAtomicOr(gimage2DArray   image, ivec3 P, int data)
   int  imageAtomicOr(gimageCubeArray image, ivec3 P, int data)
   int  imageAtomicOr(gimage2DMS image, ivec2 P, int sample, int data)
   int  imageAtomicOr(gimage2DMSArray image, ivec3 P, int sample, int data)
shader.imageAtomicXor|imageAtomicXor -- atomically compute the logical exclusive OR of a value
                 with an existing value in memory, store that value and
                 return the original value
   uint imageAtomicXor(gimage1D image, int   P, uint data)
   uint imageAtomicXor(gimage2D image, ivec2 P, uint data)
   uint imageAtomicXor(gimage3D image, ivec3 P, uint data)
   uint imageAtomicXor(gimage2DRect image, ivec2 P, uint data)
   uint imageAtomicXor(gimageCube   image, ivec3 P, uint data)
   uint imageAtomicXor(gbufferImage image, int   P, uint data)
   uint imageAtomicXor(gimage1DArray   image, ivec2 P, uint data)
   uint imageAtomicXor(gimage2DArray   image, ivec3 P, uint data)
   uint imageAtomicXor(gimageCubeArray image, ivec3 P, uint data)
   uint imageAtomicXor(gimage2DMS image, ivec2 P, int sample, uint data)
   uint imageAtomicXor(gimage2DMSArray image, ivec3 P, int sample, uint data)
   int  imageAtomicXor(gimage1D image, int   P, int data)
   int  imageAtomicXor(gimage2D image, ivec2 P, int data)
   int  imageAtomicXor(gimage3D image, ivec3 P, int data)
   int  imageAtomicXor(gimage2DRect image, ivec2 P, int data)
   int  imageAtomicXor(gimageCube   image, ivec3 P, int data)
   int  imageAtomicXor(gbufferImage image, int   P, int data)
   int  imageAtomicXor(gimage1DArray   image, ivec2 P, int data)
   int  imageAtomicXor(gimage2DArray   image, ivec3 P, int data)
   int  imageAtomicXor(gimageCubeArray image, ivec3 P, int data)
   int  imageAtomicXor(gimage2DMS image, ivec2 P, int sample, int data)
   int  imageAtomicXor(gimage2DMSArray image, ivec3 P, int sample, int data)
shader.imageLoad|imageLoad -- load a single texel from an image
   gvec4 imageLoad(gimage1D image, int   P)
   gvec4 imageLoad(gimage2D image, ivec2 P)
   gvec4 imageLoad(gimage3D image, ivec3 P)
   gvec4 imageLoad(gimage2DRect image, ivec2 P)
   gvec4 imageLoad(gimageCube   image, ivec3 P)
   gvec4 imageLoad(gbufferImage image, int   P)
   gvec4 imageLoad(gimage1DArray   image, ivec2 P)
   gvec4 imageLoad(gimage2DArray   image, ivec3 P)
   gvec4 imageLoad(gimageCubeArray image, ivec3 P)
   gvec4 imageLoad(gimage2DMS image, ivec2 P, int sample)
   gvec4 imageLoad(gimage2DMSArray image, ivec3 P, int sample)
shader.imageSamples|imageSamples -- return the number of samples of an image
   int imageSamples(gimage2DMS image)
   int imageSamples(gimage2DMSArray image)
shader.imageSize|imageSize -- retrieve the dimensions of an image
   int   imageSize(gimage1D image)
   ivec2 imageSize(gimage2D image)
   ivec3 imageSize(gimage3D image)
   ivec2 imageSize(gimageCube image)
   ivec3 imageSize(gimageCubeArray image)
   ivec2 imageSize(gimageRect image)
   ivec2 imageSize(gimage1DArray image)
   ivec3 imageSize(gimage2DArray image)
   int   imageSize(gimageBuffer image)
   ivec2 imageSize(gimage2DMS image)
   ivec3 imageSize(gimage2DMSArray image)
shader.imageStore|imageStore -- write a single texel into an image
   void imageStore(gimage1D image, int   P, gvec4 data)
   void imageStore(gimage2D image, ivec2 P, gvec4 data)
   void imageStore(gimage3D image, ivec3 P, gvec4 data)
   void imageStore(gimage2DRect image, ivec2 P, gvec4 data)
   void imageStore(gimageCube   image, ivec3 P, gvec4 data)
   void imageStore(gbufferImage image, int   P, gvec4 data)
   void imageStore(gimage1DArray   image, ivec2 P, gvec4 data)
   void imageStore(gimage2DArray   image, ivec3 P, gvec4 data)
   void imageStore(gimageCubeArray image, ivec3 P, gvec4 data)
   void imageStore(gimage2DMS image, ivec2 P, int sample, gvec4 data)
   void imageStore(gimage2DMSArray image, ivec3 P, int sample, gvec4 data)
shader.imulExtended|imulExtended -- perform a 32- by 32-bit multiply to produce a 64-bit result
   void imulExtended(genIType x, genIType y, out genIType msb, out genIType lsb)
shader:in|input varying qualifier (read only)
shader:inout|input and output varying qualifier (read and write)
shader:int
shader.intBitsToFloat|intBitsToFloat -- produce a floating point using an
                  encoding supplied as an integer
   genType intBitsToFloat(genIType x)
shader.interpolateAtCentroid|interpolateAtCentroid -- sample a varying at the centroid of a pixel
   float interpolateAtCentroid(float interpolant)
   vec2  interpolateAtCentroid(vec2  interpolant)
   vec3  interpolateAtCentroid(vec3  interpolant)
   vec4  interpolateAtCentroid(vec4  interpolant)
shader.interpolateAtOffset|interpolateAtOffset -- sample a varying at specified offset from the center of a pixel
   float interpolateAtOffset(float interpolant, vec2 offset)
   vec2  interpolateAtOffset(vec2  interpolant, vec2 offset)
   vec3  interpolateAtOffset(vec3  interpolant, vec2 offset)
   vec4  interpolateAtOffset(vec4  interpolant, vec2 offset)
shader.interpolateAtSample|interpolateAtSample -- sample a varying at the location of a specified sample
   float interpolateAtSample(float interpolant, int sample)
   vec2  interpolateAtSample(vec2  interpolant, int sample)
   vec3  interpolateAtSample(vec3  interpolant, int sample)
   vec4  interpolateAtSample(vec4  interpolant, int sample)
shader:invariant|Invariance defines when a particular operation will
 produce the same results as some other operation.
shader.inverse|inverse -- calculate the inverse of a matrix
   mat2  inverse(mat2  m)
   mat3  inverse(mat3  m)
   mat4  inverse(mat4  m)
   dmat2 inverse(dmat2 m)
   dmat3 inverse(dmat3 m)
   dmat4 inverse(dmat4 m)
shader.inversesqrt|inversesqrt -- return the inverse of the square root of the parameter
   genType  inversesqrt(genType  x)
   genDType inversesqrt(genDType x)
shader.isampler1D|1D texture binding unit for integer textures
shader.isampler1DArray|1D texture array binding unit for integer textures
shader.isampler2D|2D texture binding unit for integer textures
shader.isampler2DArray|2D texture array binding unit for integer textures
shader.isampler2DMS|2D multi sample texture binding unit for integer textures
shader.isampler2DMSArray|2D multi sample texture array binding unit for integer textures
shader.isampler2DRect|2D rectangular texture binding unit for integer textures
shader.isampler3D|3D texture binding unit for integer textures
shader.isamplerBuffer|buffer texture binding unit for integer textures
shader.isamplerCube|cube map texture binding unit for integer textures
shader.isamplerCubeArray|cube map texture array binding unit for integer textures
shader.isinf|isinf -- determine whether the parameter is positive or negative infinity
   genBType isinf(genType x)
   genBType isinf(genDType x)
shader.isnan|isnan -- determine whether the parameter is a number
   genBType isnan(genType x)
   genBType isnan(genDType x)
shader:ivec2
shader:ivec3
shader:ivec4
shader:layout|Layout qualifiers affect where the storage for a variable
 comes from, as well as other user-facing properties of a
 particular definition. Syntax:
   layout(qualifier1, qualifier2 = value, ...) variable_definition
shader:layout.binding|The binding unit of the shader resource.
shader:layout.component|Used in combination with the location qualifier
 to address specific vec-components of the stream.
shader:layout.depth_any|Disables the depth test.
shader:layout.depth_greater|To pass the depth test the new depth value must be greater.
shader:layout.depth_less|To pass the depth test the new depth value must be less.
shader:layout.depth_unchanged|To pass the depth test the new depth value must be equal.
shader:layout.early_fragment_tests|Perform depth test before executing the shader.
shader:layout.index|Used in combination with the location qualifier for dual source blending.
shader:layout.local_size_x|
shader:layout.local_size_y|
shader:layout.local_size_z|
shader:layout.location|Assigns the stream to the specified unit.
shader:layout.offset|Atomic counters also have an optional offset parameter.
 The offset is the byte offset from the beginning of the
 range bound to the target to the location where this
 variable gets its 32-bits of storage.
shader:layout.origin_upper_left|Specifies that gl_FragCoord​ will have the origin
 (0, 0) in the upper-left of the screen.
shader:layout.pixel_center_integer|Specifies that the X and Y of gl_FragCoord​ will
 be shifted by a half-pixel, so that the center
 of each pixel is an integer value.
shader:layout.std140|Force variables to be vec4 aligned.
shader:layout.vertices|Specify a particular vertex count for Tessellation Control Shaders output patches.
shader:layout.xfb_buffer|Specifies the transform feedback output buffer.
shader:layout.xfb_offset|Specifies the first position of the transform feedback output buffer to be written to.
shader:layout.xfb_stride|Specifies the stride between transform feedback buffer outputs.
shader:layout.points|The output primitive type of the geometry shader are points.
shader:layout.lines|The output primitive type of the geometry shader are lines.
shader:layout.lines_adjacency|The output primitive type of the geometry shader are adjacency lines.
shader:layout.max_vertices|The number must be a compile-time constant, and it
 defines the maximum number of vertices that will
 be written by a single invocation of the GS.
shader:layout.triangles|The output primitive type of the geometry shader are triangles.
shader:layout.triangles_adjacency|The output primitive type of the geometry shader are adjacency triangles.
shader:layout.line_strip|The output primitive type of the geometry shader are line strips.
shader:layout.triangle_strip|The output primitive type of the geometry shader are triangles strips.
shader:layout.r8
shader:layout.r8i
shader:layout.r8ui
shader:layout.r16
shader:layout.r16i
shader:layout.r16ui
shader:layout.r16f
shader:layout.r32i
shader:layout.r32ui
shader:layout.r32f
shader:layout.rg8
shader:layout.rg8i
shader:layout.rg8ui
shader:layout.rg16
shader:layout.rg16i
shader:layout.rg16ui
shader:layout.rg16f
shader:layout.rg32i
shader:layout.rg32ui
shader:layout.rg32f
shader:layout.rgb8
shader:layout.rgb8i
shader:layout.rgb8ui
shader:layout.rgb16
shader:layout.rgb16i
shader:layout.rgb16ui
shader:layout.rgb16f
shader:layout.rgb32i
shader:layout.rgb32ui
shader:layout.rgb32f
shader:layout.rgba8
shader:layout.rgba8i
shader:layout.rgba8ui
shader:layout.rgba16
shader:layout.rgba16i
shader:layout.rgba16ui
shader:layout.rgba16f
shader:layout.rgba32i
shader:layout.rgba32ui
shader:layout.rgba32f
shader.ldexp|ldexp -- assemble a floating point number from a value and exponent
   genType  ldexp(genType  x, genIType exp)
   genDType ldexp(genDType x, genIType exp)
shader.length|length -- calculate the length of a vector
   float  length(genType  x)
   double length(genDType x)
shader.lessThan|lessThan -- perform a component-wise less-than comparison of two vectors
   bvec lessThan(vec  x, vec  y)
   bvec lessThan(ivec x, ivec y)
   bvec lessThan(uvec x, uvec y)
shader.lessThanEqual|lessThanEqual -- perform a component-wise less-than-or-equal comparison of two vectors
   bvec lessThanEqual(vec  x, vec  y)
   bvec lessThanEqual(ivec x, ivec y)
   bvec lessThanEqual(uvec x, uvec y)
shader.log|log -- return the natural logarithm of the parameter
   genType log(genType x)
shader.log2|log2 -- return the base 2 logarithm of the parameter
   genType log2(genType x)
shader:mat2
shader:mat2x2
shader:mat2x3
shader:mat2x4
shader:mat3
shader:mat3x2
shader:mat3x3
shader:mat3x4
shader:mat4
shader:mat4x2
shader:mat4x3
shader:mat4x4
shader.matrixCompMult|matrixCompMult -- perform a component-wise multiplication of two matrices
   mat  matrixCompMult(mat  x, mat  y)
   dmat matrixCompMult(dmat x, dmat y)
shader.max|max -- return the greater of two values
   genType  max(genType  x, genType  y)
   genType  max(genType  x, float    y)
   genDType max(genDType x, genDType y)
   genDType max(genDType x, double   y)
   genIType max(genIType x, genIType y)
   genIType max(genIType x, int      y)
   genUType max(genUType x, genUType y)
   genUType max(genUType x, uint     y)
shader.memoryBarrier|memoryBarrier -- controls the ordering of memory transactions
                 issued by a single shader invocation
   uint memoryBarrier(void)
shader.memoryBarrierAtomicCounter|memoryBarrierAtomicCounter -- controls the ordering of operations on atomic
                             counters issued by a single shader invocation
   void memoryBarrierAtomicCounter(void)
shader.memoryBarrierBuffer|memoryBarrierBuffer -- controls the ordering of operations on buffer
                      variables issued by a single shader invocation
   void memoryBarrierBuffer(void)
shader.memoryBarrierImage|memoryBarrierImage -- controls the ordering of operations on image
                     variables issued by a single shader invocation
   void memoryBarrierImage(void)
shader.memoryBarrierShared|memoryBarrierShared -- controls the ordering of operations on shared
                       variables issued by a single shader invocation
   void memoryBarrierShared(void)
shader.min|min -- return the lesser of two values
   genType  min(genType  x, genType  y)
   genType  min(genType  x, float    y)
   genDType min(genDType x, genDType y)
   genDType min(genDType x, double   y)
   genIType min(genIType x, genIType y)
   genIType min(genIType x, int      y)
   genUType min(genUType x, genUType y)
   genUType min(genUType x, uint     y)
shader.mix|mix -- linearly interpolate between two values
   genType  mix(genType  x, genType  y, genType  a)
   genType  mix(genType  x, genType  y, float    a)
   genDType mix(genDType x, genDType y, genDType a)
   genDType mix(genDType x, genDType y, double   a)
   genType  mix(genType  x, genType  y, genBType a)
   genDType mix(genDType x, genDType y, genBType a)
   genIType mix(genIType x, genIType y, genBType a)
   genUType mix(genUType x, genUType y, genBType a)
   genBType mix(genBType x, genBType y, genBType a)
shader.mod|mod -- compute value of one parameter modulo another
   genType  mod(genType  x, float    y)
   genType  mod(genType  x, genType  y)
   genDType mod(genDType x, double   y)
   genDType mod(genDType x, genDType y)
shader.modf|modf -- separate a value into its integer and fractional components
   genType  modf(genType  x, out genType  i)
   genDType modf(genDType x, out genDType i)
shader.noise1|noise1 — generate values with a pseudo-random noise function
   float noise1(genType x)
shader.noise2|noise2 — generate values with a pseudo-random noise function
   vec2 noise2(genType x)
shader.noise3|noise3 — generate values with a pseudo-random noise function
   vec3 noise3(genType x)
shader.noise4|noise4 — generate values with a pseudo-random noise function
   vec4 noise4(genType x)
shader:noperspective|The value will be linearly interpolated in window-space.
shader.normalize|normalize — calculate the normalize product of two vectors
   genType  normalize(genType  v)
   genDType normalize(genDType v)
shader.not|not — logically invert a boolean vector
   bvec not(bvec x)
shader.notEqual|notEqual — perform a component-wise not-equal-to comparison of two vectors
    bvec notEqual(vec x, vec y)
    bvec notEqual(ivec x, ivec y)
    bvec notEqual(uvec x, uvec y)
shader:out|output varying qualifier
shader.outerProduct|outerProduct — calculate the outer product of a pair of vectors
   mat2    outerProduct(vec2  c, vec2  r)
   mat3    outerProduct(vec3  c, vec3  r)
   mat4    outerProduct(vec4  c, vec4  r)
   mat2x3  outerProduct(vec3  c, vec2  r)
   mat3x2  outerProduct(vec2  c, vec3  r)
   mat2x4  outerProduct(vec4  c, vec2  r)
   mat4x2  outerProduct(vec2  c, vec4  r)
   mat3x4  outerProduct(vec4  c, vec3  r)
   mat4x3  outerProduct(vec3  c, vec4  r)
   dmat2   outerProduct(dvec2 c, dvec2 r)
   dmat3   outerProduct(dvec3 c, dvec3 r)
   dmat4   outerProduct(dvec4 c, dvec4 r)
   dmat2x3 outerProduct(dvec3 c, dvec2 r)
   dmat3x2 outerProduct(dvec2 c, dvec3 r)
   dmat2x4 outerProduct(dvec4 c, dvec2 r)
   dmat4x2 outerProduct(dvec2 c, dvec4 r)
   dmat3x4 outerProduct(dvec4 c, dvec3 r)
   dmat4x3 outerProduct(dvec3 c, dvec4 r)
shader.packDouble2x32|packDouble2x32 — create a double-precision value
                  from a pair of unsigned integers
   double packDouble2x32(uvec2 v)
shader.packHalf2x16|packHalf2x16 — convert two 32-bit floating-point
                quantities to16-bit quantities and
                pack them into a single 32-bit integer
   uint packHalf2x16(vec2 v)
shader.packSnorm2x16|packSnorm2x16 — pack floating-point values into an unsigned integer
   uint packSnorm2x16(vec2 v)
shader.packSnorm4x8|packSnorm4x8 — pack floating-point values into an unsigned integer
   uint packSnorm4x8(vec4 v)
shader.packUnorm2x16|packUnorm2x16 — pack floating-point values into an unsigned integer
   uint packUnorm2x16(vec2 v)
shader.packUnorm4x8|packUnorm4x8 — pack floating-point values into an unsigned integer
   uint packUnorm4x8(vec4 v)
shader:patch|Per patch variable qualifier.
shader.pow|pow — return the value of the first parameter raised to the power of the second
   genType pow(genType x, genType y)
shader:precision|Floating point and integer precision qualifier.
 This affects all collections of that basic type.
shader:precision.highp|high precision
shader:precision.lowp|low precision
shader:precision.mediump|medium precision
shader.radians|radians — convert a quantity in degrees to radians
   genType radians(genType degrees)
shader.reflect|reflect — calculate the reflection direction for an incident vector
   genType  reflect(genType  I, genType  N)
   genDType reflect(genDType I, genDType N)
shader.refract|refract — calculate the refraction direction for an incident vector
   genType  refract(genType  I, genType  N, float eta)
   genDType refract(genDType I, genDType N, float eta)
shader:return
shader.round|round — find the nearest integer less than or equal to the parameter
   genType  round(genType  x)
   genDType round(genDType x)
shader.roundEven|roundEven — find the nearest even integer to the parameter
   genType  roundEven(genType  x)
   genDType roundEven(genDType x)
shader.sample|The sample​ qualifier forces OpenGL to interpolate this qualifier
 to the location of the particular sample for each generated
 fragment. This is only really useful with per-sample shading.
shader:sampler1D|1D texture binding unit
shader:sampler1DArray|1D texture array binding unit
shader:sampler1DArrayShadow|1D shadow texture array binding unit
shader:sampler1DShadow|1D shadow texture binding unit
shader:sampler2D|2D texture binding unit
shader:sampler2DArray|2D texture array binding unit
shader:sampler2DArrayShadow|2D shadow texture array binding unit
shader:sampler2DMS|2D multi-sample texture binding unit
shader:sampler2DMSArray|2D multi-sample texture array binding unit
shader:sampler2DRect|2D rectangular texture array binding unit
shader:sampler2DRectShadow|2D rectangular shadow texture array binding unit
shader:sampler2DShadow|2D shadow texture binding unit
shader:sampler3D|3D texture array binding unit
shader:samplerBuffer|buffer texture binding unit
shader:samplerCube|cube map binding unit
shader:samplerCubeArray|cube map array binding unit
shader:samplerCubeArrayShadow|shadow cube map array binding unit
shader:samplerCubeShadow|shadow cube map binding unit
shader.sign|sign — extract the sign of the parameter
   genType  sign(genType  x)
   genIType sign(genIType x)
   genDType sign(genDType x)
shader.sin|sin — return the sine of the parameter
shader.sinh|sinh — return the hyperbolic sine of the parameter
shader:smooth|The value will be interpolated in a perspective-correct
 fashion. This is the default if no qualifier is present.
shader.smoothstep|smoothstep — perform Hermite interpolation between two values
   genType  smoothstep(genType  edge0, genType  edge1, genType  x)
   genType  smoothstep(float    edge0, float    edge1, genType  x)
   genDType smoothstep(genDType edge0, genDType edge1, genDType x)
   genDType smoothstep(double   edge0, double   edge1, genDType x)
shader.sqrt|sqrt — return the square root of the parameter
   genType  sqrt(genType  x)
   genDType sqrt(genDType x)
shader.step|step — generate a step function by comparing two values
   genType step(genType edge, genType x)
   genType step(float edge, genType x)
   genDType step(genDType edge, genDType x)
   genDType step(double edge, genDType x)
shader.subroutine|Subroutines are special GLSL functions which can have
 variations. The specific variation that will be called
 is selected by the OpenGL code.
shader.tan|tan — return the tangent of the parameter
   genType tan(genType x)
shader.tanh|tanh — return the hyperbolic tangent of the parameter
   genType tanh(genType x)
shader.texelFetch|texelFetch -- perform a lookup of a single texel within a texture
   gvec4 texelFetch(gsampler1D sampler, int P, int lod)
   gvec4 texelFetch(gsampler2D sampler, ivec2 P, int lod)
   gvec4 texelFetch(gsampler3D sampler, ivec3 P, int lod)
   gvec4 texelFetch(gsampler2DRect sampler, ivec2 P)
   gvec4 texelFetch(gsampler1DArray sampler, ivec2 P, int lod)
   gvec4 texelFetch(gsampler2DArray sampler, ivec3 P, int lod)
   gvec4 texelFetch(gsamplerBuffer sampler, int P)
   gvec4 texelFetch(gsampler2DMS sampler, ivec2 P, sample sample)
   gvec4 texelFetch(gsampler2DMSArray sampler, ivec3 P, sample sample)
shader.texelFetchOffset|texelFetchOffset -- perform a lookup of a single texel within a texture with an offset
   gvec4 texelFetchOffset(gsampler1D sampler, int P, int lod, int offset)
   gvec4 texelFetchOffset(gsampler2D sampler, ivec2 P, int lod, int offset)
   gvec4 texelFetchOffset(gsampler3D sampler, ivec3 P, int lod, int offset)
   gvec4 texelFetchOffset(gsampler2DRect  sampler, ivec2 P, int offset)
   gvec4 texelFetchOffset(gsampler1DArray sampler, ivec2 P, int lod, int offset)
   gvec4 texelFetchOffset(gsampler2DArray sampler, ivec3 P, int lod, int offset)
shader.texture|texture -- retrieves texels from a texture
   gvec4 texture(gsampler1D sampler, float P, [float bias])
   gvec4 texture(gsampler2D sampler, vec2 P, [float bias])
   gvec4 texture(gsampler3D sampler, vec3 P, [float bias])
   gvec4 texture(gsamplerCube sampler, vec3  P, [float bias])
   float texture(sampler1DShadow sampler, vec3 P, [float bias])
   float texture(sampler2DShadow sampler, vec3 P, [float bias])
   float texture(samplerCubeShadow sampler, vec3 P, [float bias])
   gvec4 texture(gsampler1DArray sampler, vec2 P, [float bias])
   gvec4 texture(gsampler2DArray sampler, vec3 P, [float bias])
   gvec4 texture(gsamplerCubeArray sampler, vec4 P, [float bias])
   float texture(sampler1DArrayShadow sampler, vec3 P, [float bias])
   float texture(gsampler2DArrayShadow sampler, vec4 P, [float bias])
   gvec4 texture(gsampler2DRect sampler, vec2 P)
   float texture(sampler2DRectShadow sampler, vec3 P)
   float texture(gsamplerCubeArrayShadow sampler, vec4 P, float compare)
shader.textureGather|textureGather -- gathers four texels from a texture
   gvec4 textureGather(gsampler2D sampler, vec2 P, [int comp])
   gvec4 textureGather(gsampler2DArray sampler, vec3 P, [int comp])
   gvec4 textureGather(gsamplerCube sampler, vec3 P, [int comp])
   gvec4 textureGather(gsamplerCubeArray sampler, vec4 P, [int comp])
   gvec4 textureGather(gsampler2DRect sampler, vec3 P, [int comp])
   vec4  textureGather(gsampler2DShadow  sampler, vec2 P, float refZ)
   vec4  textureGather(gsampler2DArrayShadow sampler, vec3 P, float refZ)
   vec4  textureGather(gsamplerCubeShadow sampler, vec3 P, float refZ)
   vec4  textureGather(gsamplerCubeArrayShadow sampler, vec4 P, float refZ)
   vec4  textureGather(gsampler2DRectShadow sampler, vec3 P, float refZ)
shader.textureGatherOffset|textureGatherOffset -- gathers four texels from a texture with offset
   gvec4 textureGatherOffset(gsampler2D sampler, vec2 P, ivec2 offset, [int comp])
   gvec4 textureGatherOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, [int comp])
   gvec4 textureGatherOffset(gsampler2DRect sampler, vec3 P, ivec2 offset, [int comp])
   vec4  textureGatherOffset(gsampler2DShadow sampler, vec2 P, float refZ, ivec2 offset)
   vec4  textureGatherOffset(gsampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offset)
   vec4  textureGatherOffset(gsampler2DRectShadow  sampler, vec3 P, float refZ, ivec2 offset)
shader.textureGatherOffsets|textureGatherOffsets -- gathers four texels from a texture with an array of offsets
   gvec4 textureGatherOffsets(gsampler2D sampler, vec2 P, ivec2 offsets[4], [int comp])
   gvec4 textureGatherOffsets(gsampler2DArray sampler, vec3 P, ivec2 offsets[4], [int comp])
   gvec4 textureGatherOffsets(gsampler2DRect sampler, vec3 P, ivec2 offsets[4], [int comp])
   vec4  textureGatherOffsets(gsampler2DShadow sampler, vec2 P, float refZ, ivec2 offsets[4])
   vec4  textureGatherOffsets(gsampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offsets[4])
   vec4  textureGatherOffsets(gsampler2DRectShadow  sampler, vec3 P, float refZ, ivec2 offsets[4])
shader.textureGrad|textureGrad -- perform a texture lookup with explicit gradients
   gvec4 textureGrad(gsampler1D sampler, float P, float dPdx, float dPdy)
   gvec4 textureGrad(gsampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy)
   gvec4 textureGrad(gsampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy)
   gvec4 textureGrad(gsamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy)
   gvec4 textureGrad(gsampler2DRect sampler, vec2 P, vec2 dPdx, vec2 dPdy)
   float textureGrad(gsampler2DRectShadow sampler, vec2 P, vec2  dPdx, vec2 dPdy)
   float textureGrad(sampler1DShadow sampler, vec3 P, float dPdx, float dPdy)
   float textureGrad(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy)
   gvec4 textureGrad(gsampler1DArray sampler, vec2 P, float dPdx, float dPdy)
   gvec4 textureGrad(gsampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy)
   float textureGrad(sampler1DArrayShadow sampler, vec3 P, float dPdx, float dPdy)
   gvec4 textureGrad(gsamplerCubeArray sampler, vec4  P, vec3 dPdx, vec3 dPdy)
shader.textureLod|textureLod -- perform a texture lookup with explicit level-of-detail
   gvec4 textureLod(gsampler1D sampler, float P, float lod)
   gvec4 textureLod(gsampler2D sampler, vec2 P, float lod)
   gvec4 textureLod(gsampler3D sampler, vec3 P, float lod)
   gvec4 textureLod(gsamplerCube sampler, vec3 P, float lod)
   float textureLod(sampler1DShadow sampler, vec3 P, float lod)
   float textureLod(sampler2DShadow sampler, vec4 P, float lod)
   gvec4 textureLod(gsampler1DArray sampler, vec2 P, float lod)
   gvec4 textureLod(gsampler2DArray sampler, vec3 P, float lod)
   float textureLod(sampler1DArrayShadow sampler, vec3 P, float lod)
   gvec4 textureLod(gsamplerCubeArray sampler, vec4 P, float lod)
shader.textureOffset|textureOffset -- perform a texture lookup with offset
   gvec4 textureOffset(gsampler1D sampler, float P, int offset, [float bias])
   gvec4 textureOffset(gsampler2D sampler, vec2 P, ivec2 offset, [float bias])
   gvec4 textureOffset(gsampler3D sampler, vec3 P, ivec3 offset, [float bias])
   gvec4 textureOffset(gsampler2DRect sampler, vec2 P, ivec2 offset)
   float textureOffset(sampler2DRectShadow  sampler, vec3  P, ivec2 offset)
   float textureOffset(sampler1DShadow sampler, vec3 P, int offset, [float bias])
   float textureOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, [float bias])
   gvec4 textureOffset(gsampler1DArray sampler, vec2 P, int offset, [float bias])
   gvec4 textureOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, [float bias])
   float textureOffset(sampler1DArrayShadow sampler, vec3 P, int offset)
   float textureOffset(sampler2DArrayShadow sampler, vec4 P, vec2 offset)
shader.textureProj|textureProj -- perform a texture lookup with projection
   vec4  textureProj(gsampler1D sampler, vec2 P, [float bias])
   gvec4 textureProj(gsampler1D sampler, vec4 P, [float bias])
   gvec4 textureProj(gsampler2D sampler, vec3 P, [float bias])
   gvec4 textureProj(gsampler2D sampler, vec4 P, [float bias])
   gvec4 textureProj(gsampler3D sampler, vec4 P, [float bias])
   float textureProj(sampler1DShadow sampler, vec4 P, [float bias])
   float textureProj(sampler2DShadow sampler, vec4 P, [float bias])
   gvec4 textureProj(gsampler2DRect sampler, vec3 P)
   gvec4 textureProj(gsampler2DRect sampler, vec4 P)
   float textureProj(gsampler2DRectShadow sampler, vec4 P)
shader.textureProjGrad|textureProjGrad​ -- perform a texture lookup with projection and explicit gradients
   gvec4 textureProjGrad(gsampler1D sampler, vec2 P, float pDx, float pDy)
   gvec4 textureProjGrad(gsampler1D sampler, vec4 P, float pDx, float pDy)
   gvec4 textureProjGrad(gsampler2D sampler, vec3 P, vec2 pDx, vec2 pDy)
   gvec4 textureProjGrad(gsampler2D sampler, vec4 P, vec2 pDx, vec2 pDy)
   gvec4 textureProjGrad(gsampler3D sampler, vec4 P, vec3 pDx, vec3 pDy)
   float textureProjGrad(sampler1DShadow sampler, vec4 P, float pDx, float pDy)
   float textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 pDx, vec2 pDy)
   gvec4 textureProjGrad(gsampler2DRect sampler, vec3 P, vec2 pDx, vec2 pDy)
   gvec4 textureProjGrad(gsampler2DRect sampler, vec4 P, vec2 pDx, vec2 pDy)
   float textureProjGrad(gsampler2DRectShadow sampler, vec4 P, vec2 pDx, vec2 pDy)
shader.textureProjGradOffset|textureProjGradOffset​ -- perform a texture lookup with projection, explicit gradients and offset
   gvec4 textureProjGradOffset(gsampler1D sampler, vec2 P, float dPdx, float dPdy, int offset)
   gvec4 textureProjGradOffset(gsampler1D sampler, vec4 P, float dPdx, float dPdy, int offset)
   gvec4 textureProjGradOffset(gsampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
   gvec4 textureProjGradOffset(gsampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
   gvec4 textureProjGradOffset(gsampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset)
   float textureProjGradOffset(sampler1DShadow sampler, vec4 P, float dPdx, float dPdy, int offset)
   float textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
   gvec4 textureProjGradOffset(gsampler2DRect sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
   gvec4 textureProjGradOffset(gsampler2DRect sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
   float textureProjGradOffset(gsampler2DRectShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
shader.textureProjLod|textureProjLod​ -- perform a texture lookup with projection and explicit level-of-detail
   vec4  textureProjLod(gsampler1D sampler, vec2 P, float lod)
   gvec4 textureProjLod(gsampler1D sampler, vec4 P, float lod)
   gvec4 textureProjLod(gsampler2D sampler, vec3 P, float lod)
   gvec4 textureProjLod(gsampler2D sampler, vec4 P, float lod)
   gvec4 textureProjLod(gsampler3D sampler, vec4 P, float lod)
   float textureProjLod(sampler1DShadow sampler, vec4 P, float lod)
   float textureProjLod(sampler2DShadow sampler, vec4 P, float lod)
shader.textureProjLodOffset|textureProjLodOffset​ -- perform a texture lookup with projection and explicit level-of-detail and offset
   gvec4 textureProjLodOffset(gsampler1D sampler, vec2 P, float lod, int offset)
   gvec4 textureProjLodOffset(gsampler1D sampler, vec4 P, float lod, int offset)
   gvec4 textureProjLodOffset(gsampler2D sampler, vec3 P, float lod, ivec2 offset)
   gvec4 textureProjLodOffset(gsampler2D sampler, vec4 P, float lod, ivec2 offset)
   gvec4 textureProjLodOffset(gsampler3D sampler, vec4 P, float lod, ivec3 offset)
   float textureProjLodOffset(sampler1DShadow sampler, vec4 P, float lod, int   offset)
   float textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset)
shader.textureProjOffset|textureProjOffset​ -- perform a texture lookup with projection and offset
   gvec4 textureProjOffset(gsampler1D sampler, vec2 P, int offset, [float bias])
   gvec4 textureProjOffset(gsampler1D sampler, vec4 P, int offset, [float bias])
   gvec4 textureProjOffset(gsampler2D sampler, vec3 P, ivec2 offset, [float bias])
   gvec4 textureProjOffset(gsampler2D sampler, vec4 P, ivec2 offset, [float bias])
   gvec4 textureProjOffset(gsampler3D sampler, vec4 P, ivec3 offset, [float bias])
   float textureProjOffset(sampler1DShadow sampler, vec4 P, int   offset, [float bias])
   float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, [float bias])
   gvec4 textureProjOffset(gsampler2DRect sampler, vec3 P, ivec2 offset)
   gvec4 textureProjOffset(gsampler2DRect sampler, vec4 P, ivec2 offset)
   float textureProjOffset(gsampler2DRectShadow sampler, vec4 P, ivec2 offset)
shader.textureQueryLevels|textureQueryLevels -- compute the number of accessible mipmap levels of a texture
   int textureQueryLevels(gsampler1D sampler)
   int textureQueryLevels(gsampler2D sampler)
   int textureQueryLevels(gsampler3D sampler)
   int textureQueryLevels(gsamplerCube sampler)
   int textureQueryLevels(gsampler1DArray sampler)
   int textureQueryLevels(gsampler2DDArray sampler)
   int textureQueryLevels(gsamplerCubeArray sampler)
   int textureQueryLevels(gsampler1DShadow sampler)
   int textureQueryLevels(gsampler2DShadow sampler)
   int textureQueryLevels(gsamplerCubeShadow sampler)
   int textureQueryLevels(gsampler1DArrayShadow sampler)
   int textureQueryLevels(gsampler2DArrayShadow sampler)
   int textureQueryLevels(gsamplerCubeArrayShadow sampler)
shader.textureQueryLod|textureQueryLod -- compute the level-of-detail that would be used to sample from a texture
   vec2 textureQueryLod(gsampler1D sampler, float P)
   vec2 textureQueryLod(gsampler2D sampler, vec2  P)
   vec2 textureQueryLod(gsampler3D sampler, vec3  P)
   vec2 textureQueryLod(gsamplerCube sampler, vec3  P)
   vec2 textureQueryLod(gsampler1DArray sampler, float P)
   vec2 textureQueryLod(gsampler2DDArray sampler, vec2  P)
   vec2 textureQueryLod(gsamplerCubeArray sampler, vec3  P)
   vec2 textureQueryLod(gsampler1DShadow sampler, float P)
   vec2 textureQueryLod(gsampler2DShadow sampler, vec2  P)
   vec2 textureQueryLod(gsamplerCubeShadow sampler, vec3  P)
   vec2 textureQueryLod(gsampler1DArrayShadow sampler, float P)
   vec2 textureQueryLod(gsampler2DArrayShadow sampler, vec2  P)
   vec2 textureQueryLod(gsamplerCubeArrayShadow sampler, vec3  P)
shader.textureSamples|textureSamples -- return the number of samples of a texture
   int textureSamples(gsampler2DMS sampler)
   int textureSamples(gsampler2DMSArray sampler)
shader.textureSize|textureSize -- retrieve the dimensions of a level of a texture
   int   textureSize(gsampler1D sampler, int lod)
   ivec2 textureSize(gsampler2D sampler, int lod)
   ivec3 textureSize(gsampler3D sampler, int lod)
   ivec2 textureSize(gsamplerCube sampler, int lod)
   int   textureSize(sampler1DShadow sampler, int lod)
   ivec2 textureSize(sampler2DShadow sampler, int lod)
   ivec2 textureSize(samplerCubeShadow sampler, int lod)
   ivec3 textureSize(samplerCubeArray sampler, int lod)
   ivec3 textureSize(samplerCubeArrayShadow sampler, int lod)
   ivec2 textureSize(gsamplerRect sampler)
   ivec2 textureSize(gsamplerRectShadow sampler)
   ivec2 textureSize(gsampler1DArray sampler, int lod)
   ivec3 textureSize(gsampler2DArray sampler, int lod)
   ivec2 textureSize(sampler1DArrayShadow sampler, int lod)
   ivec3 textureSize(sampler2DArrayShadow sampler, int lod)
   int   textureSize(gsamplerBuffer sampler)
   ivec2 textureSize(gsampler2DMS sampler)
   ivec3 textureSize(gsampler2DMSArray sampler)
shader.transpose|transpose — calculate the transpose of a matrix
   mat2    transpose(mat2    m)
   mat3    transpose(mat3    m)
   mat4    transpose(mat4    m)
   mat2x3  transpose(mat3x2  m)
   mat2x4  transpose(mat4x2  m)
   mat3x2  transpose(mat2x3  m)
   mat3x4  transpose(mat4x3  m)
   mat4x2  transpose(mat2x4  m)
   mat4x3  transpose(mat3x4  m)
   dmat2   transpose(dmat2   m)
   dmat3   transpose(dmat3   m)
   dmat4   transpose(dmat4   m)
   dmat2x3 transpose(dmat3x2 m)
   dmat2x4 transpose(dmat4x2 m)
   dmat3x2 transpose(dmat2x3 m)
   dmat3x4 transpose(dmat4x3 m)
   dmat4x2 transpose(dmat2x4 m)
   dmat4x3 transpose(dmat3x4 m)
shader.trunc|trunc — find the nearest integer less
          than or equal to the parameter
   genType  trunc(genType  x)
   genDType trunc(genDType x)
shader.uaddCarry|uaddCarry — Add unsigned integers and generate carry. The
              carry result is the sum of x and y modulo 2^32.
   genUType uaddCarry(genUType x, genUType y, out genUType carry)
shader:uint
shader.uintBitsToFloat|uintBitsToFloat -- produce a floating point using an
                    encoding supplied as an integer
   genType uintBitsToFloat(genUType x)
shader.umulExtended|umulExtended -- perform a 32- by 32-bit multiply to produce a 64-bit result
   void umulExtended(genIType x, genIType y, out genIType msb, out genIType lsb)
shader:uniform|uniform (buffer) qualifier
shader.unpackDouble2x32|unpackDouble2x32 — produce two unsigned integers containing the bit
                     encoding of a double precision floating point value
   uvec2 unpackDouble2x32(double d)
shader.unpackHalf2x16|unpackHalf2x16 — convert two 16-bit floating-point values
                   packed into a single 32-bit integer into a
                   vector of two 32-bit floating-point quantities
   vec2 unpackHalf2x16(uint v)
shader.unpackSnorm2x16|unpackSnorm2x16 — unpack floating-point values from an unsigned integer
   vec2 unpackUnorm2x16(uint p)
shader.unpackSnorm4x8|unpackSnorm2x16 — unpack floating-point values from an unsigned integer
   vec2 unpackSnorm4x8(uint p)
shader.unpackUnorm2x16|unpackSnorm2x16 — unpack floating-point values from an unsigned integer
   vec2 unpackUnorm2x16(uint p)
shader.unpackUnorm4x8|unpackSnorm2x16 — unpack floating-point values from an unsigned integer
   vec2 unpackUnorm4x8(uint p)
shader:usampler1D|1D texture binding unit for unsigned integer textures
shader:usampler1DArray|1D texture array binding unit for unsigned integer textures
shader:usampler2D|2D texture binding unit for unsigned integer textures
shader:usampler2DArray|2D texture array binding unit for unsigned integer textures
shader:usampler2DMS|2D multi sample texture binding unit for unsigned integer textures
shader:usampler2DMSArray|2D multi sample texture array binding unit for unsigned integer textures
shader:usampler2DRect|2D rectangular texture binding unit for unsigned integer textures
shader:usampler3D|3D texture binding unit for unsigned integer textures
shader:usamplerBuffer|buffer texture binding unit for unsigned integer textures
shader:usamplerCube|cube map texture binding unit for unsigned integer textures
shader:usamplerCubeArray|cube map texture array binding unit for unsigned integer textures
shader.usubBorrow|usubBorrow -- subtract unsigned integers and generate borrow
   genUType usubBorrow(genUType x, genUType y, out genUType borrow)
shader:uvec2
shader:uvec3
shader:uvec4
shader:vec2
shader:vec3
shader:vec4
shader:void
shader:while
shader:writeonly
tech|tech <name>
tech.pass|pass <name>
tech.init|Execute this pass only once
 before all 'normal' passes.
   init <name>
text|text <name>
texture|texture <name>
texture.buff|buff <name>
texture.img|img <name>
texture.samp|samp <name>
vertinput|vertinput <name>
vertinput.attr|attr <buff_name> <type> <dim> [stride] [offset] [divisor]
vertinput.attr.byte
vertinput.attr.double
vertinput.attr.float
vertinput.attr.int
vertinput.attr.short
vertinput.attr.ubyte
vertinput.attr.uint
vertinput.attr.unsignedByte
vertinput.attr.unsignedInt
vertinput.attr.unsignedShort
vertinput.attr.ushort
vertoutput|vertoutput <name>
vertoutput.buff|buff <name>
vertoutput.pause|pause <true_false>
vertoutput.resume|resume <true_false>